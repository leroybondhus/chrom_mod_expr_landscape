---
title: "main"
output: html_document
date: "2023-01-27"
author: "Leroy Bondhus"
---

```{r set up dir structure}
                         
dirs <- list(data="./data/",
             results = "./results/",
             tables = "./results/tables/",
             figures = "./results/figures/",
             temp_data ="/u/scratch/l/leroybon/chrom_mod_expr_landscape/",
             OMIM_data = "./data/omim_ra/")
for(dir in dirs){
  if(!dir.exists(dir)){dir.create(dir)}
};rm(dir)

files <- list()

####
date <- format(Sys.time(),"%Y%m%d")
```

```{r setup note}
#### NOTE : USER HAS TO REQUEST ACCESS TO A LINK FROM OMIM DIRECTLY TO GET THIS FILE #####
####        ONCE THIS IS DONE REPLACE "NULL" BELOW WITH THE URL TO genemap2.txt FILE #####

#OMIM_genemap2_URL <- "https://data.omim.org/downloads/##USER_ACCESS_PATTERN##/genemap2.txt"
OMIM_genemap2_URL <- NULL
#if(is.null(OMIM_genemap2_URL){rm(OMIM_genemap2_URL)}
####                                     END NOTE                                    #####

files$OMIM_GENE <- paste0(dirs$OMIM_data,"HPO_genes_to_phenotypes.txt")
if(!file.exists(files$OMIM_GENE)){
  if(!exists("OMIM_genemap2_URL")){
    stop(paste0( "Please visit https://www.omim.org/downloads and follow instructions to get URL link ",
                 "for 'genemap2.txt', then set OMIM_genemap2_URL variable to this link in this script " ))
  }
  download.file(OMIM_genemap2_URL, files$OMIM_GENE)
}
rm(OMIM_genemap2_URL)     
```

```{r load libraries}
req_packages <- list(
  standard = c("BiocManager","doParallel","ggplot2","stringr", "reshape2", "XML",
               "ggiraph","ggraph","igraph","collapsibleTree"),
  biocmanager = c("Gviz","biomaRt")
)
for(std_package in req_packages$standard ){
  if(!require(std_package, quietly=T, character.only=T)){install.packages(std_package)}
};rm(std_package)
for(bioc_package in req_packages$biocmanager ){
  if(!require(bioc_package, quietly=T, character.only=T)){BiocManager::install(bioc_package)}
};rm(bioc_package)
rm(req_packages)

date <- format(Sys.time(),"%Y%m%d")
```


```{r, ontos helper functions}
## assume ontology is list of elements of equal length
## elements must include "id", "name", "parents", "children"

add_children_from_parents <- function(onto){
  for(i in 1:length(onto$id)){
    if(length(onto$parents[[i]])<1){next}
    which <- which(is.element(onto$id, onto$parents[[i]]))
    for(j in which){
      onto$children[[j]] <- c(onto$children[[j]], onto$id[i])
    }
  }
  return(onto)
}


get_ancestors <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$parents[[which]]) == 0){
    return(onto$id[which])
  }
  ancestors <- id
  for(parent in onto$parents[[which]]){
    ancestors <- unique(c(ancestors, get_ancestors(parent, onto)))
  }
  return(ancestors)
}


add_height <- function(onto, descendant_relations=c(), descend_through_children=TRUE, min_or_max=function(x){max(x)}){
  onto$height <- numeric(length=length(onto$id))
  
  add_height_helper <- function(id, onto, descendant_relations, descend_through_children, visited_ids=c()){
    which <- which(onto$id==id)
    if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
    if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
    relation_df <- onto$relations[[which]]
    transitive_ids <- relation_df$id[which(is.element(relation_df$relation, descendant_relations))]
    if(descend_through_children){
      transitive_ids <- unique(c(transitive_ids,onto$children[[which]]))
    }
    if(length(transitive_ids) == 0){ 
      onto$height[which] <- 1
      return(onto)
    }
    transitive_and_visited_ids <- transitive_ids[which(is.element(transitive_ids, visited_ids))]
    for(tid in transitive_and_visited_ids){
      if(onto$height[which(onto$id==tid)]==0){
        onto$height[which(onto$id==tid)] <- -min_or_max(c(-Inf,Inf))
      }
    }
    transitive_ids_unassigned <- onto$id[which(onto$height == 0 & is.element(onto$id, transitive_ids))]
    while(length(transitive_ids_unassigned) > 0 ){
      tid <- transitive_ids_unassigned[1]
      onto <- add_height_helper(tid, onto, descendant_relations, descend_through_children,
                                visited_ids = c(visited_ids,id,tid))
      transitive_ids_unassigned <- onto$id[which(onto$height == 0 & is.element(onto$id, transitive_ids))]
    }
    
    onto$height[which] <- min_or_max(onto$height[which(is.element(onto$id, transitive_ids))])+1
    return(onto)
  }
  for(i in 1:length(onto$id)){
    #print(i)
    if(i %% 1000 == 1){print(i)}
    if(onto$height[i] != 0){next}
    onto <- add_height_helper(onto$id[i], onto,
                              descendant_relations=descendant_relations,
                              descend_through_children=descend_through_children )
  }
  inf_check_num = 1
  while(length(which(is.infinite(onto$height))) > 0){
    print(paste("fixing prelim inf height assignments: iteration", inf_check_num))
    inf_check_num <- inf_check_num+1
    inf_ids <- onto$id[which(is.infinite(onto$height))]
    print(paste("num inf: ", length(inf_ids)))
    for(inf_id in inf_ids){
      onto <- add_height_helper(inf_id, onto,
                               descendant_relations=descendant_relations,
                               descend_through_children=descend_through_children)
    }
    if(inf_check_num > 10){stop("stopping: possible infinite loop - check logic in ontology and that from descendant_relations used")}
  }
  return(onto)
}


add_depth <- function(onto, ascendent_relations=c(), ascend_through_parents=TRUE, min_or_max=function(x){min(x)} ){
  onto$depth <- numeric(length=length(onto$id))
  add_depth_helper <- function(id, onto, ascendent_relations, ascend_through_parents, visited_ids=c()){
    which <- which(onto$id==id)
    if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
    if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
    relation_df <- onto$relations[[which]]
    transitive_ids <- relation_df$id[which(is.element(relation_df$relation, ascendent_relations))]
    if(ascend_through_parents){
      transitive_ids <- unique(c(transitive_ids,onto$parents[[which]]))
    }
    if(length(transitive_ids) == 0){
      onto$depth[which] <- 1
      return(onto)
    }
    ## flips sign so that all infinite loops always lose eventual comparison
    transitive_and_visited_ids <- transitive_ids[which(is.element(transitive_ids, visited_ids))]
    for(tid in transitive_and_visited_ids){
      if(onto$depth[which(onto$id==tid)] == 0){
        onto$depth[which(onto$id==tid)] <- -min_or_max(c(-Inf,Inf))
      }
    }
    transitive_ids_unassigned <- onto$id[which(onto$depth == 0 & is.element(onto$id, transitive_ids))]
    while(length(transitive_ids_unassigned) > 0 ){
      tid  <- transitive_ids_unassigned[1]
      onto <- add_depth_helper(tid, onto, ascendent_relations, ascend_through_parents,
                               visited_ids=c(visited_ids, id, tid))
      transitive_ids_unassigned <- onto$id[which(onto$depth == 0 & is.element(onto$id, transitive_ids))]
    }
    onto$depth[which] <- min_or_max(onto$depth[which(is.element(onto$id, transitive_ids) )])+1 # & onto$depth >0)])+1
    return(onto)
  }
  for(i in 1:length(onto$id)){
    if(i%%1000==1){print(i)}
    if(onto$depth[i] != 0 & !is.infinite(onto$depth[i])){next}
    onto <- add_depth_helper(onto$id[i], onto,
                              ascendent_relations=ascendent_relations,
                              ascend_through_parents=ascend_through_parents)
  }
  inf_check_num = 1
  while(length(which(is.infinite(onto$depth))) > 0){
    print(paste("fixing prelim inf depth assignments: iteration", inf_check_num, ": num inf:",length(which(is.infinite(onto$depth)))))
    inf_check_num <- inf_check_num+1
    inf_ids <- onto$id[which(is.infinite(onto$depth))]
    for(inf_id in inf_ids){
      onto <- add_depth_helper(inf_id, onto,
                               ascendent_relations=ascendent_relations,
                               ascend_through_parents=ascend_through_parents)
    }
  }
  return(onto)
}

get_mask_set <- function(id, onto){ #}, mask_self=T){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(onto$is_signif[which] ){
    return(onto$id[which]) ## if signif, end recursion down since don't need to also mask descendants
  } else {
    mask_set <- character(length=0)
  }
  if(length(onto$children[[which]]) > 0){ 
    for(child in onto$children[[which]]){
      mask_set <- c(mask_set, get_mask_set(child,onto)) # ,mask_self=F)) 
    }
  }
  return(unique(mask_set))
}



### need to modify to enable extracting PART_OF relations here...... O_o
### get table of onto term and all descendants
get_desc_summary_table <- function(id,onto, level=1,
                                   transitive_relations=c(),
                                   descend_through_children=TRUE,
                                   visited_ids=c()){
  which <- which(onto$id==id) 
  if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
  if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}

  temp_df <- as.data.frame(matrix(character() ,nrow = 1, ncol=length(onto),
                                  dimnames = list(NULL, names(onto))))
  for(el in names(onto)){
    if(is.data.frame(onto[[el]][[which]])){
      temp_df[el] <- paste0(apply(onto[[el]][[which]],1, paste0, collapse=","),collapse=";")
    } else if( is.list(onto[[el]][[which]] )){
      if(length(onto[[el]][[which]]) > 0){
       temp_df[el] <- sapply(onto[[el]][[which]], paste, collapse=",")
      } else { temp_df[el] <- NA }
    } else{
      temp_df[el] <- paste0(onto[[el]][[which]],collapse=",")
    } 
  }
  temp_df <- cbind(temp_df, data.frame(level=level))

  relation_df <- onto$relations[[which]]
  transitive_ids <- relation_df$id[which(is.element(relation_df$relation, transitive_relations))]
  if(descend_through_children){
    transitive_ids <- unique(c(transitive_ids,onto$children[[which]]))
  }
  transitive_ids <- transitive_ids[!is.element(transitive_ids, visited_ids)]
  if(length(transitive_ids) > 0 ){
    for(tid in transitive_ids){
      temp_df <- rbind(temp_df,
                       get_desc_summary_table(tid, onto, level=level+1,
                                              transitive_relations=transitive_relations,
                                              descend_through_children=descend_through_children,
                                              visited_ids=c(visited_ids,tid,id)))
    }
  }
  return(unique(temp_df))
}


get_desc_tree <- function(id,onto, level=1,
                          descendent_relations=c(),  ### descendent and ascendent need to be pairs... 
                          ascendent_relations=c(),   ### descendent and ascendent need to be pairs... 
                          descend_through_children=TRUE,
                          ascend_through_parents=TRUE,
                          visited_ids=c(),
                          prefix=c(),
                          max_level=Inf){
  which <- which(onto$id==id) 
  if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
  if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
  
  relation_df <- onto$relations[[which]]
  
  if(level==1){
    temp_df$term_parent <- NA
    temp_df$term <- onto$id[which]
    temp_df$level <- level
    temp_df <- data.frame(term_parent = NA, term =id, level=level)
  } else {
    ascendent_ids <- relation_df$id[which(is.element(relation_df$relation, ascendent_relations))]
    if(ascend_through_parents){
      ascendent_ids <- unique(c(ascendent_ids,onto$parents[[which]]))
    }
    ascendent_ids <- ascendent_ids[which(is.element(ascendent_ids, visited_ids))]
    temp_df <- data.frame(term_parent=ascendent_ids,term=id,level=level)
  }
  
  descendant_ids <- relation_df$id[which(is.element(relation_df$relation, descendent_relations))]
  if(descend_through_children){
    descendant_ids <- unique(c(descendant_ids,onto$children[[which]]))
  }
  descendant_ids <- descendant_ids[!is.element(descendant_ids, visited_ids)]
  if(length(descendant_ids) > 0 & level < max_level){
    for(tid in descendant_ids){
      temp_df <- rbind(temp_df,
                       get_desc_tree(tid, onto, level=level+1,
                                     descendent_relations=descendent_relations,
                                     ascendent_relations=ascendent_relations,
                                     descend_through_children=descend_through_children,
                                     ascend_through_parents=ascend_through_parents,
                                     visited_ids=c(visited_ids,tid,id),
                                     prefix = paste0(prefix,",",id),
                                     max_level = max_level))
    }
  }
  temp_df <- temp_df[order(temp_df$level),]
  return(unique(temp_df))
}



add_inverse_relation <- function(onto, relation, inverse_relation_name=NA){
  if(is.na(inverse_relation_name)){
    inverse_relation_name=paste0("INVERSE(",relation,")")
  }
  for(i in 1:length(onto$id)){
    complement_ids <- onto$relations[[i]]$id[which(onto$relations[[i]]$relation == relation)]
    if(length(complement_ids)==0){next}
    for(ci in complement_ids){
      which <- which(onto$id==ci)
      onto$relations[[which]] <- rbind(onto$relations[[which]],
                                       data.frame(relation=inverse_relation_name, id=onto$id[i]))
    }
  }
  return(onto)
}



add_descendants <- function(onto, descendant_relations=c(), descend_through_children=TRUE){
  onto$descendants <- vector("list",length=length(onto$id))
  add_descendants_helper <- function(id, onto, descendant_relations, descend_through_children,visited_ids=c()){
    which <- which(onto$id==id)
    if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
    if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
    visited_ids <- c(visited_ids, id)
    relation_df <- onto$relations[[which]]
    all_transitive_ids <- relation_df$id[which(is.element(relation_df$relation, descendant_relations))]
    if(descend_through_children){
      all_transitive_ids <- unique(c(all_transitive_ids,onto$children[[which]]))
    }
    if(length(all_transitive_ids) > 0){
      onto$descendants[[which]] <- unique(c(onto$descendants[[which]],all_transitive_ids))
    }
    transitive_ids <- all_transitive_ids[!is.element(all_transitive_ids, visited_ids)]
    if(length(transitive_ids) == 0){
      if(length(onto$descendants[[which]]==0)){
        onto$descendants[[which]] <- NA 
      }
      return(onto)
    }
    transitive_ids_unassigned <- onto$id[which( sapply(onto$descendants,length) == 0 & is.element(onto$id, transitive_ids))]
    for(tid in transitive_ids_unassigned){
     # print(tid)
      visited_ids <- c(visited_ids, tid)
      onto <- add_descendants_helper(tid, onto, descendant_relations, descend_through_children, visited_ids)
    }
    for(tid in all_transitive_ids){
      onto$descendants[[which]] <- unique(c(onto$descendants[[which]],
                                            onto$descendants[[which(onto$id == tid)]]))
    }
    return(onto)
  }
  
  for(i in 1:length(onto$id)){
    if(i %% 1000 == 0){print(i)}
    if(length(onto$descendants[[i]]) > 0){next}
    onto <- add_descendants_helper(onto$id[i], onto,
                              descendant_relations=descendant_relations,
                              descend_through_children=descend_through_children )
  }
  return(onto)
}

```

```{r, organize ontologies}


ontos <- list()
ontos$go = list(
  URL = "http://purl.obolibrary.org/obo/go.obo"
)

files$go_obo <- paste0(dirs$temp_data,"go.obo")
download.file(ontos$go$URL,files$go_obo)

##### read in and set up ontology ####
con <- file(files$go_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^\\[Term\\]$",line)
}
close(con);rm(con,line)

ontos$go$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  relations = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
con <- file(files$go_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    term_num <- term_num + 1
  } else if(grepl("^id:.*GO:",line)){
    ontos$go$ont$id[term_num] <- str_extract(line, "GO:[0-9]+")
  } else if(grepl("^name:",line)){
    ontos$go$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^namespace:",line)){
    ontos$go$ont$namespace[term_num] <- str_remove(line, "^namespace:[[:space:]]")
  } else if(grepl("^is_a:",line)){
    ontos$go$ont$parents[term_num][[1]] <- c(ontos$go$ont$parents[term_num][[1]], str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line)){
    ontos$go$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con);rm(con,term_num,num_terms,line)

### replace is_a with parents
### add children attribute to each term for ease of navigation up and down ontology
ontos$go$ont <- add_children_from_parents(ontos$go$ont)
ontos$go$ont <- add_descendants(ontos$go$ont)
##### done: read in and set up ontology ####





## uberon
## hpo
ontos$hpo <- list()
ontos$hpo$URL <- "https://github.com/obophenotype/human-phenotype-ontology/raw/master/hp.obo"

files$hp_obo <- paste0(dirs$temp_data,"hp.obo")
download.file(ontos$hpo$URL,files$hp_obo)


con <- file(files$hp_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^\\[Term\\]$",line)
}
close(con);rm(con,line)

ontos$hpo$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  relations = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
con <- file(files$hp_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    term_num <- term_num + 1
  } else if(grepl("^id:.*HP:",line)){
    ontos$hpo$ont$id[term_num] <- str_extract(line, "HP:[0-9]+")
  } else if(grepl("^name:",line)){
    ontos$hpo$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^is_a:",line)){
    ontos$hpo$ont$parents[term_num][[1]] <- c(ontos$hpo$ont$parents[term_num][[1]], str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line)){
    ontos$hpo$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con);rm(con,term_num,num_terms)
ontos$hpo$ont <- add_children_from_parents(ontos$hpo$ont)
ontos$hpo$ont <- add_depth(ontos$hpo$ont)
ontos$hpo$ont <- add_height(ontos$hpo$ont)
ontos$hpo$ont <- add_descendants(ontos$hpo$ont)

## set up uberon ontology ###
ontos$uberon <- list()
ontos$uberon$URL <- "https://github.com/obophenotype/uberon/releases/download/v2023-02-14/uberon-full.obo"

files$uberon_obo <- paste0(dirs$temp_data,"uberon-full.obo")
download.file(ontos$uberon$URL,files$uberon_obo)

con <- file(files$uberon_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^id:.*UBERON:",line)
}
close(con);rm(con,line)

ontos$uberon$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
#  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  relations = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
is_uberon <- FALSE
con <- file(files$uberon_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    is_uberon <- FALSE
  } else if(grepl("^id:.*UBERON:",line)){
    term_num <- term_num + 1
    ontos$uberon$ont$id[term_num] <- str_extract(line, "UBERON:[0-9]+")
    is_uberon <- TRUE
  } else if(grepl("^name:",line) & is_uberon){
    ontos$uberon$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^is_a:.*UBERON",line) & is_uberon){
    ontos$uberon$ont$parents[term_num][[1]] <- c(ontos$uberon$ont$parents[term_num][[1]],
                                                 #str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*"))
                                                 str_extract(line, "UBERON:[0-9]*"))
  } else if(grepl("^relationship:.*UBERON",line) & is_uberon){
    temp_relation  <- str_remove(str_remove(line, "^relationship:[[:space:]]"),"[[:space:]]*!.*")
    temp_df <- data.frame(relation = str_remove(temp_relation, " .*"),
                          id = str_extract(temp_relation, "UBERON:[0-9]+"))
    temp_gci_relation <- str_remove(str_remove(str_extract(line,"gci_relation.*\""),"gci_relation=\""),"\"")
    ## if gci_relation exists and does not match temp_df$relation skip
    if(!is.na(temp_gci_relation) & temp_gci_relation != temp_df$relation){next} 
    ontos$uberon$ont$relations[term_num][[1]] <- rbind(ontos$uberon$ont$relations[term_num][[1]],
                                                       temp_df) 
      # c(ontos$uberon$ont$parents[term_num][[1]],
      # str_remove(str_remove(line, "^relationship:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line) & is_uberon){
    ontos$uberon$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con);rm(con, line, term_num, num_terms, 
               temp_relation, is_uberon, temp_df)

### NOTE: FIX UBERON IMPROPER ANNOTATIONS: 

##### remove: UBERON:0003983 has_part UBERON:0007181 ## conus arteriosus has_part serosa of infundibulum of uterine tube
##### remove: UBERON:0003983 has_part UBERON:0007182 ## conus arteriosus has_part muscle layer of infundibulum of uterine tube
##### consider removal: UBERON:0005984 has_part UBERON:0001021: subendocardium layer has_part nerve ##
######### above may be my misunderstanding of UBERON has_part annotation precise meaning ###
##### remove: UBERON:0001378 part_of UBERON:0001377  ## quadriceps femoris has_part rectus femoris ## preserve is_a relation
##### remove: UBERON:0001379 part_of UBERON:0001377  ## quadriceps femoris has_part vastus lateralis ## preserve is_a relation 
##### remove: UBERON:0001380 part_of UBERON:0001377  ## quadriceps femoris has_part vastus medialis ## preserve is_a relation
##### remove: UBERON:0014847 part_of UBERON:0001377  ## quadriceps femoris has_part vastus intermedius ## preserve is_a relation


which <- which(ontos$uberon$ont$id=="UBERON:0003983")
which_keep <- which(!(grepl("UBERON:000718[12]",ontos$uberon$ont$relations[[which]]$id) &
                  grepl("has_part",ontos$uberon$ont$relations[[which]]$relation)))
ontos$uberon$ont$relations[[which]] <- ontos$uberon$ont$relations[[which]][which_keep,]

for(id in c("UBERON:0001378","UBERON:0001379","UBERON:0001380","UBERON:0014847")){
  which <- which(ontos$uberon$ont$id==id)
  which_keep <- which(!(grepl("UBERON:0001377",ontos$uberon$ont$relations[[which]]$id) &
                          grepl("part_of",ontos$uberon$ont$relations[[which]]$relation)))
  ontos$uberon$ont$relations[[which]] <- ontos$uberon$ont$relations[[which]][which_keep,]
}
rm(which, which_keep, id)
#################


ontos$uberon$ont <- add_children_from_parents(ontos$uberon$ont)
ontos$uberon$ont <- add_inverse_relation(ontos$uberon$ont, "part_of",
                                         inverse_relation_name = "has_part(SUPP_INV(part_of))")
ontos$uberon$ont <- add_depth(ontos$uberon$ont, ascendent_relations = c("part_of"))
ontos$uberon$ont <- add_height(ontos$uberon$ont, descendant_relations = c("has_part(SUPP_INV(part_of))"))
ontos$uberon$ont <- add_descendants(ontos$uberon$ont, descendant_relations = c("has_part(SUPP_INV(part_of))"))

save.image()


```



```{r, organize onto_maps}
onto_maps <- list()
onto_maps$OMIM_GENE <- list()

##### read in and set up MIM gene to disease database (aka map) ####
con <- file(files$OMIM_GENE,open="r")
temp_header <- readLines(con, 4)[4]
temp_header <- str_remove(temp_header,"# ")
temp_header <- str_split_1(temp_header,"\t")
close(con);rm(con)
onto_maps$OMIM_GENE$map <- read.delim2(files$OMIM_GENE, header=FALSE, comment.char="#")
colnames(onto_maps$OMIM_GENE$map) <- str_replace_all(temp_header,"[[:space:]]","_")
onto_maps$OMIM_GENE$map <- onto_maps$OMIM_GENE$map[complete.cases(onto_maps$OMIM_GENE$map),]
### FURTHER PARSING NECESSARY: COLUMN "Phenotypes" contains actual phenotype OMIM ID, MIM_Number is for gene's mim number...
###                            for "Phenotypes" column, only use those associated with (3) which indicates gene found causative
onto_maps$OMIM_GENE$map <- onto_maps$OMIM_GENE$map[,c("Ensembl_Gene_ID","Phenotypes")]

temp <- str_split(onto_maps$OMIM_GENE$map$Phenotypes,";")
names(temp) <- onto_maps$OMIM_GENE$map$Ensembl_Gene_ID
temp <- melt(temp); colnames(temp) <- c("Phenotype","Ensembl_Gene_ID")
temp$temp_str <- str_extract(temp$Phenotype,"[0-9]{6}.*\\([0-4]\\).*")
temp$evidence_code <- str_extract(temp$temp_str,"\\([0-4]\\)")
temp$inheritance_mode <- str_extract(temp$temp_str,"[a-zA-Z].*")
temp$OMIM_ID <- str_extract(temp$temp_str,"[0-9]{6}")
temp$temp_str <- NULL
temp$Phenotype <-  str_remove(temp$Phenotype,", [0-9]{6}.*")

onto_maps$OMIM_GENE$map <- temp
rm(temp,temp_header)

onto_maps$HPO_OMIM <- list()
##### try other file......
onto_maps$HPO_OMIM$URL <- "http://purl.obolibrary.org/obo/hp/hpoa/phenotype.hpoa"
files$HPO_OMIM <- paste0(dirs$temp_data,"phenotype.hpoa")
download.file(onto_maps$HPO_OMIM$URL, files$HPO_OMIM)
### column descriptors https://hpo-annotation-qc.readthedocs.io/en/latest/annotationFormat.html#phenotype-hpoa-format
##### read in and set up HPO gene to phenotype map ####
onto_maps$HPO_OMIM$map <- read.csv(files$HPO_OMIM,sep="\t",skip=4)
onto_maps$HPO_OMIM$map <- onto_maps$HPO_OMIM$map[grepl("OMIM",onto_maps$HPO_OMIM$map$database_id),]
colnames(onto_maps$HPO_OMIM$map)[which(colnames(onto_maps$HPO_OMIM$map)=="database_id")] <- "OMIM_ID"
colnames(onto_maps$HPO_OMIM$map)[which(colnames(onto_maps$HPO_OMIM$map)=="hpo_id")] <- "HPO_ID"



onto_maps$HPO_OMIM_GENE <- list()
temp1 <- onto_maps$HPO_OMIM$map[,c("OMIM_ID","HPO_ID")]
temp2 <- onto_maps$OMIM_GENE$map[c("Ensembl_Gene_ID","OMIM_ID")]
temp2$OMIM_ID <- paste0("OMIM:",temp2$OMIM_ID)
onto_maps$HPO_OMIM_GENE$map <- merge(temp1,temp2)
rm(temp1,temp2)


### HPO to UBERON
## hpo
onto_maps$HPO_UBERON <- list()
onto_maps$HPO_UBERON$URL <- "http://purl.obolibrary.org/obo/hp.owl"

files$hp_owl <- paste0(dirs$temp_data,"hp.owl")
download.file(onto_maps$HPO_UBERON$URL,files$hp_owl)


con <- file(files$hp_owl,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("<!--.*HP_",line)
}
close(con)

onto_maps$HPO_UBERON$map <- list(
  HPO_id=character(length = num_terms ),
  UBERON_terms = vector("list", num_terms)
)

term_num <- 0
on_HPO_term <- FALSE
con <- file(files$hp_owl,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("<!--.*HP_",line)){
    term_num <- term_num + 1
    onto_maps$HPO_UBERON$map$HPO_id[term_num] <- str_extract(line, "HP_[0-9]+")
    on_HPO_term <- TRUE
  } else if(grepl("UBERON",line) & on_HPO_term){
    onto_maps$HPO_UBERON$map$UBERON_terms[[term_num]] <- c(onto_maps$HPO_UBERON$map$UBERON_terms[[term_num]], 
                                                        str_extract(line, "UBERON_[0-9]+"))
  } else if(grepl("<!--",line)){
    on_HPO_term <- FALSE
  }
}
close(con);rm(con, line, on_HPO_term, term_num, num_terms)

onto_maps$HPO_UBERON$map$UBERON_terms[sapply(onto_maps$HPO_UBERON$map$UBERON_terms, is.null)] <- NA 
names(onto_maps$HPO_UBERON$map$UBERON_terms) <- onto_maps$HPO_UBERON$map$HPO_id
temp <- reshape2::melt(onto_maps$HPO_UBERON$map$UBERON_terms)
colnames(temp) <- c("UBERON_ID","HPO_ID")
temp$UBERON_ID <- str_replace_all(temp$UBERON_ID, "_",":")
temp$HPO_ID <- str_replace_all(temp$HPO_ID,"_",":")
onto_maps$HPO_UBERON$map <- temp[,c("HPO_ID","UBERON_ID")]
onto_maps$HPO_UBERON$map <- onto_maps$HPO_UBERON$map[is.element(onto_maps$HPO_UBERON$map$HPO_ID, ontos$hpo$ont$id),]
## 
### fill in missing uberon terms from map - find deepest HPO term with some UBERON mapped to it
for(i in 1:nrow(onto_maps$HPO_UBERON$map)){
  if(i %% 1e3 == 0){print(i)}
  if(!is.na(onto_maps$HPO_UBERON$map$UBERON_ID[i])){next}
  ancestors  <- get_ancestors(onto_maps$HPO_UBERON$map$HPO_ID[i], ontos$hpo$ont)
  which <- which(is.element(ontos$hpo$ont$id,ancestors))
  temp_df <- data.frame(id = ontos$hpo$ont$id[which],
                        name=ontos$hpo$ont$name[which],
                        height=ontos$hpo$ont$height[which],
                        depth=ontos$hpo$ont$depth[which])
  temp_df$UBERON <- onto_maps$HPO_UBERON$map$UBERON_ID[match(temp_df$id, onto_maps$HPO_UBERON$map$HPO_ID)]
  temp_df <- temp_df[complete.cases(temp_df),]
  if(nrow(temp_df)==0){next}
  onto_maps$HPO_UBERON$map$UBERON_ID[i] <- temp_df$UBERON[which.max(temp_df$depth)[1]] 
}
rm(temp, temp_df, ancestors, i, which)

onto_maps$HPO_UBERON_GENE <- list()
onto_maps$HPO_UBERON_GENE$map <- merge(onto_maps$HPO_OMIM_GENE$map, onto_maps$HPO_UBERON$map)

save.image()

```


```{r, organize gene sets}
ensembl <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
options(timeout=300)
gene_sets <- list()
### these pulls are fairly time intensive -> consider saving to data in short term and load if exists
gene_sets$genes_all <- getBM(attributes=c('ensembl_gene_id',"external_gene_name",
                                          "start_position","end_position"),
                 mart = ensembl, useCache = F)

## alternatively download from: http://geneontology.org/gene-associations/goa_human.gaf.gz
# temp <- tempfile()
# download.file("http://geneontology.org/gene-associations/goa_human.gaf.gz", paste0(dirs$temp_data,"goa_human.gaf.gz")) 
# gene_sets$genes_all_go <- read.table( temp, skip=0, header = FALSE, sep = "\t",comment.char = "!",fill = T)


for(chr in c(as.character(1:22),"X","Y","MT" )){
  print(chr)
  temp <- getBM(attributes=c('ensembl_gene_id',"external_gene_name",
                             "ensembl_transcript_id","transcript_length",
                             "chromosome_name", "exon_chrom_start","exon_chrom_end","rank"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  print("transcript info")
  temp2 <- getBM(attributes=c('ensembl_gene_id',
                             "ensembl_transcript_id",
                             "transcript_is_canonical"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  print("canon labels")
  temp <- merge(temp, temp2)
  gene_sets$genes_all_transcript <- rbind(gene_sets$genes_all_transcript, temp)
  
  temp <- getBM(attributes=c('ensembl_gene_id',"external_gene_name","go_id","name_1006"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  print("go terms")
  gene_sets$genes_all_go <- rbind(gene_sets$genes_all_go, temp)
  
}
gene_sets$genes_all_transcript <- gene_sets$genes_all_transcript[which(!is.na(gene_sets$genes_all_transcript$transcript_is_canonical)),]

gene_sets$human_chromatin_modifiers <- list()
gene_sets$human_chromatin_modifiers$go_terms = c( "histone acetyltransferase activity",
                                        "histone deacetylase activity",
                                        "histone methyltransferase activity",
                                        "histone demethylase activity",
                                        "histone ubiquitin ligase activity",
                                        "histone deubiquitinase activity",
                                        "histone kinase activity",
                                        "histone phosphatase activity",
                                      ##  "chromatin remodeling", too broad
                                      ##  "chromatin organization", too broad
                                        "nucleosome organization",
                                        "chromatin looping",
                                        "heterochromatin organization",
                                        "DNA-methyltransferase activity",
                                        "DNA demethylase activity")


## for each term in chrom_go_terms, check which genes are associated with term (and any of it's descendants)

gene_sets$human_chromatin_modifiers$go_ids <- character(length = length(gene_sets$human_chromatin_modifiers$go_terms))
gene_sets$human_chromatin_modifiers$gene_subsets <- vector("list",length(gene_sets$human_chromatin_modifiers$go_terms))
names(gene_sets$human_chromatin_modifiers$gene_subsets ) <- gene_sets$human_chromatin_modifiers$go_terms
for(i in 1:length(gene_sets$human_chromatin_modifiers$go_terms)){
  ## which go onto node has the current term
  which <- which(ontos$go$ont$name == gene_sets$human_chromatin_modifiers$go_terms[i])
  term_id <- ontos$go$ont$id[which]
  gene_sets$human_chromatin_modifiers$go_ids[i] <- term_id
  
  ## genes which have GO id for current term or any of it's descendants
  descendants <-ontos$go$ont$descendants[[which]]
  gene_sets$human_chromatin_modifiers$gene_subsets[[i]] <-
    unique(gene_sets$genes_all_go$ensembl_gene_id[which(is.element(gene_sets$genes_all_go$go_id, descendants ))])
  
}

gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers <- unique(unlist(gene_sets$human_chromatin_modifiers$gene_subsets))


## human
## mouse
## zebrafish
## celegans
## fly 
## chromatin modifier
rm(temp,temp2, chr,descendants,i,term_id, which)
save.image()

```

```{r, custom ggplot themes}
barcode_theme <- theme_classic()+
  theme(axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y  = element_blank(),
        axis.ticks.y = element_blank()
  )


```

```{r, look at basic chromatin modifier summary statistics}

## gene length
## transcript length
## exon count
## exon size
ggl <- list()
for(i in 14){ #  1:length(gene_sets$human_chromatin_modifiers$gene_subsets)){
  chrom_subset <- gene_sets$human_chromatin_modifiers$gene_subsets[[i]] 
  chrom_subset_name <- names(gene_sets$human_chromatin_modifiers$gene_subsets)[i]
  if(length(chrom_subset)==0){next}
  ## gene length density + barcode plots
  df <- gene_sets$genes_all[which(is.element(gene_sets$genes_all$ensembl_gene_id, chrom_subset )),]
  df$gene_length <- df$end_position - df$start_position
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length density")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(gene_length)))+
    ggtitle(temp_name)+
    geom_density(alpha=0.5)
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length barcode")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(gene_length),xend=log10(gene_length), y=0,yend=1))+
    ggtitle(temp_name)+
    geom_segment(alpha=0.5)+
    coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
    barcode_theme
  
  ## transcript length density + barcode plot
  df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, chrom_subset )),]
  df <- unique(df[,c("ensembl_gene_id", "transcript_length")])
  
  temp_name <- paste0(chrom_subset_name, ": ", "transcript_length density")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(transcript_length)))+
    ggtitle(temp_name)+
    geom_density(alpha=0.5)
  
  temp_name <- paste0(chrom_subset_name, ": ", "transcript_length barcode")
  ggl[[temp_name]] <-  ggplot(df, aes(x=log10(transcript_length),xend=log10(transcript_length), y=0,yend=1))+
    ggtitle(temp_name)+
    geom_segment(alpha=0.5)+
    coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
    barcode_theme
   
  
  
  ## exon length  plot
  df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, chrom_subset )),]
  #df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, sample(unique(gene_sets$genes_all$ensembl_gene_id),45) )),]
  df$exon_length <- df$exon_chrom_end - df$exon_chrom_start
  df$gene_factor_num <- as.numeric(as.factor(df$ensembl_gene_id))
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(exon_length),y=gene_factor_num))+
    ggtitle(temp_name)+
    geom_point(fill="grey20") +
    coord_cartesian( xlim = c(1, 4))+
    barcode_theme
  
  
  ## exon count plot
  temp_df <- as.data.frame(table(df$ensembl_transcript_id))
  colnames(temp_df)[1] <- "ensembl_transcript_id"
  colnames(temp_df)[2] <- "exon_count"
  df <- merge(df, temp_df, sort=FALSE)
  
  ## test 2d plot of exon count by min size
  
  temp <- split(df$exon_length, df$ensembl_transcript_id)
  temp <- sapply(temp, function(x) rank(-x, ties.method = "last"))
  df$exon_length_rank <- unsplit(temp, df$ensembl_transcript_id)
  
  temp <- split(df$exon_length, df$exon_length_rank) 
  temp <- sapply(temp, sort, decreasing=T)
  temp <- melt(temp)
  temp2 <- split(temp$value, temp$L1)
  num_genes <- length(unique(df$ensembl_gene_id))
  temp2 <- sapply(temp2, function(x) (1:length(x))/num_genes )
  temp2 <- unsplit(temp2, temp$L1)
  temp$percentile <- temp2
  temp$L1 <- as.numeric(temp$L1)
  temp <- temp[order(temp$L1, temp$percentile),]
  temp$L1 <- as.factor(temp$L1)
  colnames(temp) <- c("exon_length","exon_rank_by_length","percentile")
  temp_name <- paste0(chrom_subset_name, ": ", "genes_w_N_exons_of_size_or_greater")
  ggl[[temp_name]] <- ggplot(temp, aes(log10(exon_length), percentile, group=exon_rank_by_length, color=exon_rank_by_length))+
    ggtitle(temp_name)+
    geom_line()
  
  temp <- split(df$rank, df$ensembl_transcript_id)
  temp <-sapply(temp, function(x) order(-x))
  temp <- unsplit(temp, df$ensembl_transcript_id)
  df$rank_from_end <- temp
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length v rank")
  ggl[[temp_name]] <- ggplot(df, aes(rank, log10(exon_length) ))+
    ggtitle(temp_name)+
    geom_point(alpha=0.5)
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length v rank_from_end")
  ggl[[temp_name]] <- ggplot(df, aes(rank_from_end, log10(exon_length) ))+
    ggtitle(temp_name)+
    geom_point(alpha=0.5)
  
}

dirs$gene_arch_summary_figs <- paste0(dirs$figures,"gene_arch_summary_figures/")
if(!dir.exists(dirs$gene_arch_summary_figs)){dir.create(dirs$gene_arch_summary_figs)}
for(i in 1:length(ggl)){
  
  temp_filename <- paste0(dirs$gene_arch_summary_figs,names(ggl)[i],".png")
  temp_filename <- str_replace_all(temp_filename,"[ \t:]","_")
  w <- 7
  h <- ifelse(grepl("barcode", temp_filename), 3, 5)
  ggsave(temp_filename, ggl[[i]], device = "png", width=w, height=h)
}

```

```{r, look at basic disease association statistics }

### look at pLI

temp <- tempfile()
download.file("https://storage.googleapis.com/gcp-public-data--gnomad/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz",temp)
lof_metrics <- read.table( temp, skip=0, header = TRUE, sep = "\t")

temp <- tempfile()
download.file("http://geneontology.org/gene-associations/goa_human_complex.gaf.gz",temp)
go_complex_metrics <- read.table( temp, skip=0, header = TRUE, sep = "\t")

ggl2 <- list()
for(i in 14){ #  1:length(gene_sets$human_chromatin_modifiers$gene_subsets)){
  chrom_subset <- gene_sets$human_chromatin_modifiers$gene_subsets[[i]] 
  chrom_subset_name <- names(gene_sets$human_chromatin_modifiers$gene_subsets)[i]
  if(length(chrom_subset)==0){next}
  
  df <- lof_metrics[which(is.element(lof_metrics$gene_id, chrom_subset)),] 
  id_cols <- c("gene","gene_id","gene_type")
  var_cols <- c("oe_mis","oe_syn","oe_lof","no_lofs","obs_het_lof","obs_hom_lof", "pLI","oe_lof_upper","syn_z","mis_z","lof_z")
  df_melt <- melt(df, id.vars=id_cols, measure.vars = var_cols)
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length density")
  ggplot(df_melt[grep("oe", df_melt$variable),],aes(x=variable, y=value))+
    geom_violin() 
  ggplot(df_melt[grep("_z", df_melt$variable),],aes(x=variable, y=value))+
    geom_violin()
  ggplot(df_melt[grep("pLI", df_melt$variable),],aes(y=value))+
    geom_histogram()
  ggplot(df_melt[grep("oe_lof_upper", df_melt$variable),],aes(y=value))+
    geom_histogram()
  
  
  ### GET all associated with Mendelian disorder (e.g. v pLI)

}
```

```{r}
## for each HPO, test enrichment of chrom modifiers in set
## plot by signif and OR, add labels (padj by bonferroni)



which <- which(is.element(onto_maps$HPO_OMIM_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- onto_maps$HPO_OMIM_GENE$map[which,]
temp_not_chrom <- onto_maps$HPO_OMIM_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
temp_res_df <- data.frame(p.value=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio_lb=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio_ub=numeric(length(ontos$hpo$ont$id)),
                          num_chrom_associated=numeric(length(ontos$hpo$ont$id)),
                          num_non_chrom_associated=numeric(length(ontos$hpo$ont$id)))

for(i in 1:length(ontos$hpo$ont$id)){
  if(i %% 1000 == 1){print(i)}
  hps <- c(ontos$hpo$ont$id[i],ontos$hpo$ont$descendants[[i]])
  which <- which(is.element(temp_chrom$HPO_ID, hps))
  temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <- which(is.element(temp_not_chrom$HPO_ID, hps))
  temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

    ### Use all genes or only those with some HP association ?
  which <-  which(!is.element(temp_chrom$HPO_ID, hps))
  temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
  temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
  ## chrom and hp
  
  ## chrom and not hp
  ## not chrom and hp
  ## not chrom and not hp
  
  temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                  c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
  
  ## Odds Ratio
  temp_res_df$p.value[i] <- temp_res$p.value
  temp_res_df$odds_ratio[i] <- temp_res$estimate
  temp_res_df$odds_ratio_lb[i] <- temp_res$conf.int[1]
  temp_res_df$odds_ratio_ub[i] <- temp_res$conf.int[2]
  temp_res_df$num_chrom_associated[i] <- temp_chrom_hp
  temp_res_df$num_non_chrom_associated[i] <- temp_not_chrom_hp 
}
save.image()

## plot Gene-Gene phenotype similarity (asymetric if want subsumption test e.g.  if A has subset of phens of B)
## subsumption test may be useful later if make meta-genes by aggregation of complex components..... 


which <- which(is.element(onto_maps$HPO_OMIM_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- onto_maps$HPO_OMIM_GENE$map[which,]
temp_not_chrom <- onto_maps$HPO_OMIM_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
onto <- ontos$hpo$ont

onto$is_signif <- rep(F,length(onto$id))
for( layer in 1:max(onto$height)){
  print(paste0("layer is: ",layer ))
  els_in_layer <- which(onto$height==layer)
  i = 1
  for( el in els_in_layer ){
    if(i %% 250 == 0){print(i)}
    i <- i+1
    hps <-  c(onto$id[el],onto$descendants[[el]])
  
    which <- which(is.element(temp_chrom$HPO_ID, hps))
    temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <- which(is.element(temp_not_chrom$HPO_ID, hps))
    temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
      ### Use all genes or only those with some HP association ?
    which <-  which(!is.element(temp_chrom$HPO_ID, hps))
    temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
    temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
    
    temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                  c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
    
    is_signif <- temp_res$p.value < 0.05
    if(!is_signif){next}
    ## get list of signif children - these form the mask set.. 
    ## actually.. probs want all signif descendants? Probs don't
    ## need to deal with children of signif children, but children of
    ## insignif children may themselves have substantial signal/ be signif...
    ## and then drive association at later ancestor level.. 
    
    #children_subset <- which(is.element(onto$id, onto$children[[el]]))
    
    # children_subset <- which(is.element(onto$id, get_descendants(onto$id[el],onto)))
    # 
    # which_children_signif <- children_subset[which(onto$is_signif[children_subset])]
    # signif_descendants <- onto$id[which_children_signif] 
    # signif_descendants <- signif_descendants[which(!is.element(signif_descendants,onto$id[el]))] # remove _self_ from descendants
    
    signif_descendants <- get_mask_set(onto$id[el], onto)
    
    if(length(signif_descendants>0)){ ### replace with children that are already called as significant only
      for( child in signif_descendants){
        hps <- onto$id[el] ## want to retain any that are directly associated with _self_.. 
        ## NOTE: Don't want to retain _self_ in hps if database includes redundant associations.. i.e. database should
        ## only include most specific instance and NOT also all ancestors of that instance ..
        for( other_child in signif_descendants){
          if( other_child == child){next}
          hps <- c(hps, onto$descendants[[which(onto$id==other_child)]])
        } 
  
        which <- which(is.element(temp_chrom$HPO_ID, hps))
        temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <- which(is.element(temp_not_chrom$HPO_ID, hps))
        temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
      
          ### Use all genes or only those with some HP association ?
        which <-  which(!is.element(temp_chrom$HPO_ID, hps))
        temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
        temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
        
        temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                      c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
        is_signif <- temp_res$p.value < 0.05 
        if(!is_signif){break}
      }
      
    }
    onto$is_signif[el] <- is_signif
  }
}


temp_df <- cbind(data.frame(id=onto$id, name=onto$name, is_signif=onto$is_signif,
                            height=onto$height, depth=onto$depth),
                 temp_res_df)
rownames(temp_df) <- temp_df$id

ontos$hpo$chrom_enrichments <- temp_df
save.image()
filename <- paste0(dirs$tables,"chrom_modifiers_HPO_enrichments.csv")
write.csv(ontos$hpo$chrom_enrichments, file=filename)


### want to be able to get all most specific descendants... plot as a tree or hierarchy
### networkd3

library(igraph)
library(ggraph)
library(ggiraph)

onto <- ontos$hpo$ont
temp_df <- ontos$hpo$chrom_enrichments
## this gives all is_a edges... need to get all part_of edges for uberon hpo is fine without
names(onto$parents) <- onto$id
temp_edges <- melt(onto$parents[which(!sapply(onto$parents, is.null))]) 
colnames(temp_edges) <- c("from","to")
temp_edges$edge_type <- "is_a"
temp_vertices <- onto$id

## select subset of hpo ids to plot
phen_names <- c("Abnormal heart morphology", "Abnormal hair morphology")
for(phen_name in phen_names){
  which <- which(onto$name==phen_name)
  ids <- c(onto$id[which], onto$descendants[[which]])
  
  desc_sum_table <- get_desc_summary_table(onto$id[which],onto)
  desc_sum_table <- merge(desc_sum_table, ontos$hpo$chrom_enrichments)
  desc_sum_table <- desc_sum_table[,grep("parents|children|relations|is_obsolete|descendants",colnames(desc_sum_table),invert = T)]
  desc_sum_table <- desc_sum_table[order(desc_sum_table$level),]

  filename <- paste0(dirs$tables,str_replace(onto$id[which],":","_"),"_desc_summ_table.csv")
  write.csv(desc_sum_table, file=filename)
  
  ids <- c(onto$id[which], onto$descendants[[which]])
  which <-which(is.element(temp_edges$from, ids) & is.element(temp_edges$to, ids))
  temp_edges_subset <- temp_edges[which,]
  temp_vertices <- data.frame(name=ids, size=(temp_df$num_chrom_associated[match(ids,temp_df$id)]+1)*10,
                              signif_val=-log10(temp_df$p.value[match(ids,temp_df$id)]),
                              or_lb = temp_df$odds_ratio_lb[match(ids,temp_df$id)],
                              depth=temp_df$depth[match(ids,temp_df$id)],
                              height=temp_df$height[match(ids,temp_df$id)])
  temp_vertices$label <- NA
  which <- which(temp_vertices$height >= 4 |
                   temp_vertices$signif_val > 2 ) #which(temp_vertices$depth <= 6 )
  temp_vertices$label[which] <- onto$name[match(temp_vertices$name[which], onto$id)]
  
  temp_graph <- graph_from_data_frame(temp_edges_subset[,c("from","to")], vertices=temp_vertices)
  gg <- ggraph(temp_graph, layout = "circlepack",weight=size)+
    geom_node_circle(aes(fill=signif_val))+
    geom_node_label(aes(label=label,fill=signif_val), size=3,repel = TRUE) +# position = position_dodge())+
    scale_fill_gradientn(colours = c("grey40","#ffaaaa", "red","yellow"),
                         breaks = c(0,1.3, 2, 3, max(temp_vertices$signif_val) ),
                         guide="colorbar"
                         )
  filename <- paste0(dirs$figures,str_replace(onto$id[which(onto$name==phen_name)],":","_"),"_circlePack.png")
  png(filename = filename, units = "in", height = 8, width = 9, res=320)
  plot(gg)
  dev.off()
  
  
  desc_sum_tree <- get_desc_tree(onto$id[which(onto$name==phen_name)], onto,
                                 descendent_relations =  "has_part(SUPP_INV(part_of))",
                                 ascendent_relations = "part_of",
                                 max_level = 4)
  which_assoc <- which(desc_sum_table$num_non_chrom_associated + 
                           desc_sum_table$num_non_chrom_associated != 0) 
  desc_sum_tree_merge <- unique(merge(desc_sum_tree[,which(colnames(desc_sum_tree)!="level")],
                               desc_sum_table[which_assoc,which(colnames(desc_sum_table)!="level")],
                               by.x="term", by.y="id"))
  
  
  desc_sum_tree_merge <- desc_sum_tree_merge[,c(2,1,3:ncol(desc_sum_tree_merge))]
  colnames(desc_sum_tree_merge)[which(colnames(desc_sum_tree_merge)=="height")] <- "_height_"
  colnames(desc_sum_tree_merge)[which(colnames(desc_sum_tree_merge)=="name")] <- "_name_"
  desc_sum_tree_merge$size <- log2(desc_sum_tree_merge$num_chrom_associated + 1)+1
  desc_sum_tree_merge$signif <- signif(-log10(desc_sum_tree_merge$p.value),2)
  desc_sum_tree_merge$signif[which(abs(desc_sum_tree_merge$signif) < 1e-10)] <- 0
  temp_colors <- colorRamp(c("white","red"))(desc_sum_tree_merge$signif / max(desc_sum_tree_merge$signif))
  colors <- rgb(temp_colors / 255)
  desc_sum_tree_merge$color <- colors 
  desc_sum_tree_merge$term_parent <- desc_sum_tree_merge$`_name_`[match(
    desc_sum_tree_merge$term_parent, desc_sum_tree_merge$term 
  )]
  desc_sum_tree_merge$term <- desc_sum_tree_merge$`_name_`
  
  temp_html_plot <- collapsibleTreeNetwork(
    desc_sum_tree_merge,
    attribute = "signif",
    fill = "color", 
    nodeSize = "size",
    collapsed = FALSE,
    zoomable = FALSE
  )

  htmlwidgets::saveWidget(temp_html_plot, file=paste0(dirs$figures,"HPO_",
                                                      str_replace_all(phen_name," ","_"),"_ctn.html"))
  
}

save.image()
#c("darkblue", "blue", "#aaaaff" ,"white", "#ffaaaa",  "red","red4", "grey20"))


  ############
 
  
```


```{r, experimental ontology layered analysis, uberon}


## for each UBERON, test enrichment of chrom modifiers in set
## plot by signif and OR, add labels (padj by bonferroni)


which <- which(is.element(onto_maps$HPO_UBERON_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- onto_maps$HPO_UBERON_GENE$map[which,]
temp_not_chrom <- onto_maps$HPO_UBERON_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
temp_chrom <- temp_chrom[complete.cases(temp_chrom),]
temp_not_chrom <- temp_not_chrom[complete.cases(temp_not_chrom),]
temp_res_df <- data.frame(p.value=numeric(length(ontos$uberon$ont$id)),
                          odds_ratio=numeric(length(ontos$uberon$ont$id)),
                          odds_ratio_lb=numeric(length(ontos$uberon$ont$id)),
                          odds_ratio_ub=numeric(length(ontos$uberon$ont$id)),
                          num_chrom_associated=numeric(length(ontos$uberon$ont$id)),
                          num_non_chrom_associated=numeric(length(ontos$uberon$ont$id)))

#ontos$uberon$ont <- add_descendants(ontos$uberon$ont, descendant_relations = c("has_part(SUPP_INVERSE)"))

# t1 <- Sys.time()
for(i in 1:length(ontos$uberon$ont$id)){
  # t2 <- Sys.time()
  # print(paste(i,":",signif(t2-t1,2), units(t2-t1)))
  # t1 <- t2
  if(i %% 500 == 1){print(i)}
  
  ### this is slow for all uberon terms ~~ 1+ hrs guessing ... parallelize ? or speed up function
  ### probably add a add_descendants function to add a descendants element - will blow up size of ontology but speed of access probs more important +
  ### should be able to make dynamically to further speed up....
  #ubs <- get_descendants_plus(ontos$uberon$ont$id[i], ontos$uberon$ont,
   #                           descendant_relations = c("has_part","has_part(SUPP_INVERSE)"))
  ubs <- ontos$uberon$ont$descendants[[i]]
  
  which <- which(is.element(temp_chrom$UBERON_ID, ubs))
  temp_chrom_ub <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <- which(is.element(temp_not_chrom$UBERON_ID, ubs))
  temp_not_chrom_ub <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

    ### Use all genes or only those with some HP association ?
  which <-  which(!is.element(temp_chrom$UBERON_ID, hps))
  temp_chrom_not_ub <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <-  which(!is.element(temp_not_chrom$UBERON_ID, hps))
  temp_not_chrom_not_ub <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
  ## chrom and hp
  
  ## chrom and not hp
  ## not chrom and hp
  ## not chrom and not hp
  
  temp_res <- fisher.test(x=cbind(c(temp_chrom_ub, temp_chrom_not_ub),
                                  c(temp_not_chrom_ub, temp_not_chrom_not_ub)))
  
  ## Odds Ratio
  temp_res_df$p.value[i] <- temp_res$p.value
  temp_res_df$odds_ratio[i] <- temp_res$estimate
  temp_res_df$odds_ratio_lb[i] <- temp_res$conf.int[1]
  temp_res_df$odds_ratio_ub[i] <- temp_res$conf.int[2]
  temp_res_df$num_chrom_associated[i] <- temp_chrom_ub
  temp_res_df$num_non_chrom_associated[i] <- temp_not_chrom_ub 
}
save.image()

## plot Gene-Gene phenotype similarity (asymetric if want subsumption test e.g.  if A has subset of phens of B)
## subsumption test may be useful later if make meta-genes by aggregation of complex components..... 






which <- which(is.element(onto_maps$HPO_UBERON_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- onto_maps$HPO_UBERON_GENE$map[which,]
temp_not_chrom <- onto_maps$HPO_UBERON_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
temp_chrom <- temp_chrom[complete.cases(temp_chrom),]
temp_not_chrom <- temp_not_chrom[complete.cases(temp_not_chrom),]

onto <- ontos$uberon$ont

onto$is_signif <- rep(F,length(onto$id))
for( layer in 1:max(onto$height)){
  print(paste0("layer is: ",layer ))
  els_in_layer <- which(onto$height==layer)
  i = 1
  for( el in els_in_layer ){
    if(i %% 250 == 0){print(i)}
    i <- i+1
    ubs <- c(onto$id[el],onto$descendants[[el]])

    which <- which(is.element(temp_chrom$UBERON_ID, ubs))
    temp_chrom_ub <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <- which(is.element(temp_not_chrom$UBERON_ID, ubs))
    temp_not_chrom_ub <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

      ### Use all genes or only those with some HP association ?
    which <-  which(!is.element(temp_chrom$UBERON_ID, ubs))
    temp_chrom_not_ub <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <-  which(!is.element(temp_not_chrom$UBERON_ID, ubs))
    temp_not_chrom_not_ub <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

    temp_res <- fisher.test(x=cbind(c(temp_chrom_ub, temp_chrom_not_ub),
                                  c(temp_not_chrom_ub, temp_not_chrom_not_ub)))

    is_signif <- temp_res$p.value < 0.05
    if(!is_signif){next}
    ## get list of signif children - these form the mask set..
    ## actually.. probs want all signif descendants? Probs don't
    ## need to deal with children of signif children, but children of
    ## insignif children may themselves have substantial signal/ be signif...
    ## and then drive association at later ancestor level..

    #children_subset <- which(is.element(onto$id, onto$children[[el]]))

    # children_subset <- which(is.element(onto$id, get_descendants(onto$id[el],onto)))
    #
    # which_children_signif <- children_subset[which(onto$is_signif[children_subset])]
    # signif_descendants <- onto$id[which_children_signif]
    # signif_descendants <- signif_descendants[which(!is.element(signif_descendants,onto$id[el]))] # remove _self_ from descendants

    ### NEED TO UPDATE get_mask_set TO WORK WITH OTHER TRANSITIVE RELATIONS
    signif_descendants <- get_mask_set(onto$id[el], onto)

    if(length(signif_descendants>0)){ ### replace with children that are already called as significant only
      for( child in signif_descendants){
        ubs <- onto$id[el] ## want to retain any that are directly associated with _self_..
        ## NOTE: Don't want to retain _self_ in hps if database includes redundant associations.. i.e. database should
        ## only include most specific instance and NOT also all ancestors of that instance ..
        for( other_child in signif_descendants){
          if( other_child == child){next}
          ubs <- c(ubs, onto$descendants[[which(onto$id==other_child)]])
        }

        which <- which(is.element(temp_chrom$UBERON_ID, ubs))
        temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <- which(is.element(temp_not_chrom$UBERON_ID, ubs))
        temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

          ### Use all genes or only those with some HP association ?
        which <-  which(!is.element(temp_chrom$UBERON_ID, ubs))
        temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <-  which(!is.element(temp_not_chrom$UBERON_ID, ubs))
        temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

        temp_res <- fisher.test(x=cbind(c(temp_chrom_ub, temp_chrom_not_ub),
                                      c(temp_not_chrom_ub, temp_not_chrom_not_ub)))
        is_signif <- temp_res$p.value < 0.05
        if(!is_signif){break}
      }

    }
    onto$is_signif[el] <- is_signif
  }
}
temp_df <- cbind(data.frame(id=onto$id, name=onto$name,
                            height=onto$height, depth=onto$depth, is_signif=onto$is_signif),
                 temp_res_df)
rownames(temp_df) <- temp_df$id
ontos$uberon$chrom_enrichments <- temp_df
save.image()
filename <- paste0(dirs$tables,"chrom_modifiers_UBERON_enrichments.csv")
write.csv(ontos$uberon$chrom_enrichments, file=filename)

### want to be able to get all most specific descendants... plot as a tree or hierarchy
### networkd3

library(igraph)
library(ggraph)
library(ggiraph)

onto <- ontos$uberon$ont
temp_df <- ontos$uberon$chrom_enrichments
names(onto$parents) <- onto$id
## this gives all is_a edges... need to get all part_of edges for uberon hpo is fine without
temp_edges <- melt(onto$parents[which(!sapply(onto$parents, is.null))]) 
colnames(temp_edges) <- c("from","to")
temp_edges$edge_type <- "is_a"

ascendent_relations = c("has_part(SUPP_INV(part_of))")
for(i in 1:length(onto$id)){
  if(i %% 2e3 == 1){print(i)}
  rids <- onto$relations[[i]]$id[which(is.element(onto$relations[[i]]$relation, ascendent_relations))]
  rs <- onto$relations[[i]]$relation[which(is.element(onto$relations[[i]]$relation, ascendent_relations))]
  if(length(rids)==0){next}
  temp_edges <- rbind(temp_edges, 
                        data.frame(from=onto$id[i],to=rids,edge_type=rs))
}
temp_edges <- unique(temp_edges)
temp_vertices <- onto$id

## select subset of hpo ids to plot
ids_l <- list()
ids_l$heart <- ids <- c(onto$id[which(onto$name=="heart")], onto$descendants[[which(onto$name=="heart")]])
ids_l$brain <- intersect(c(onto$id[which(onto$name=="brain")], onto$descendants[[which(onto$name=="brain")]]),
                 onto$id[which(onto$height>=4)])

# ids <- unique(c(onto$children[[which(onto$name=="cardiac chamber")]],
#                 onto$children[[which(onto$name=="cardiac septum")]],
#                 onto$children[[which(onto$name=="cardiac valve")]]))

for(ids_name in names(ids_l)){
  ids <- ids_l[[ids_name]]
  ids <- ids[which(!is.na(ids))]
  which <-which(is.element(temp_edges$from, ids) & is.element(temp_edges$to, ids))
  temp_edges_subset <- unique(temp_edges[which,c("from","to")])
  
  
  
  desc_sum_table <- get_desc_summary_table(onto$id[which(onto$name == ids_name)],onto, transitive_relations = "has_part(SUPP_INV(part_of))")
  desc_sum_table <- merge(desc_sum_table, ontos$uberon$chrom_enrichments)
  desc_sum_table <- desc_sum_table[,grep("parents|children|relations|is_obsolete|descendants",colnames(desc_sum_table),invert = T)]
  desc_sum_table <- desc_sum_table[order(desc_sum_table$level),]

  filename <- paste0(dirs$tables,str_replace(onto$id[which(onto$name == ids_name)],":","_"),"_desc_summ_table.csv")
  write.csv(desc_sum_table, file=filename)
  
  
  temp_vertices <- data.frame(name=ids, size=(temp_df$num_chrom_associated[match(ids,temp_df$id)]+1)*10,
                              signif_val=-log10(temp_df$p.value[match(ids,temp_df$id)]),
                              or_lb = temp_df$odds_ratio_lb[match(ids,temp_df$id)],
                              depth=temp_df$depth[match(ids,temp_df$id)],
                              height=temp_df$height[match(ids,temp_df$id)])
  temp_vertices$label <- NA
  which <- which(temp_vertices$height >= 5 | 
                   temp_vertices$signif_val > 1.3)
  temp_vertices$label[which] <- onto$name[match(temp_vertices$name[which], onto$id)]
  
  
  temp_graph <- graph_from_data_frame(temp_edges_subset, vertices=temp_vertices)
  gg <- ggraph(temp_graph, layout = "circlepack", weight=size)+
    geom_node_circle(aes(fill=signif_val))+
    geom_node_label(aes(label=label,fill=signif_val), size=3,repel = TRUE)+#, position = position_dodge())+
    scale_fill_gradientn(colours = c("grey40","#ffaaaa", "red","yellow"),
                         breaks = c(0,1.3, 2, 3, max(temp_vertices$signif_val) ),
                         guide="colorbar"
                         )
  
  filename <- paste0(dirs$figures,str_replace(onto$id[which(onto$name==ids_name)],":","_"),"_circlePack.png")
  png(filename = filename, units = "in", height = 8, width = 9, res=320)
  plot(gg)
  dev.off()
  
  
  ############
  desc_sum_tree <- get_desc_tree(onto$id[which(onto$name==ids_name)], onto,
                                 descendent_relations =  "has_part(SUPP_INV(part_of))",
                                 ascendent_relations = "part_of",
                                 max_level = 4)
  which_assoc <- which(desc_sum_table$num_non_chrom_associated + 
                           desc_sum_table$num_non_chrom_associated != 0) 
  desc_sum_tree_merge <- unique(merge(desc_sum_tree[,which(colnames(desc_sum_tree)!="level")],
                               desc_sum_table[which_assoc,which(colnames(desc_sum_table)!="level")],
                               by.x="term", by.y="id"))
  
  
  desc_sum_tree_merge <- desc_sum_tree_merge[,c(2,1,3:ncol(desc_sum_tree_merge))]
  colnames(desc_sum_tree_merge)[which(colnames(desc_sum_tree_merge)=="height")] <- "_height_"
  colnames(desc_sum_tree_merge)[which(colnames(desc_sum_tree_merge)=="name")] <- "_name_"
  desc_sum_tree_merge$size <- log2(desc_sum_tree_merge$num_chrom_associated + 1)+1
  desc_sum_tree_merge$signif <- signif(-log10(desc_sum_tree_merge$p.value),2)
  desc_sum_tree_merge$signif[which(abs(desc_sum_tree_merge$signif) < 1e-10)] <- 0
  temp_colors <- colorRamp(c("white","red"))(desc_sum_tree_merge$signif / max(desc_sum_tree_merge$signif))
  colors <- rgb(temp_colors / 255)
  desc_sum_tree_merge$color <- colors 
  desc_sum_tree_merge$term_parent <- desc_sum_tree_merge$`_name_`[match(
    desc_sum_tree_merge$term_parent, desc_sum_tree_merge$term 
  )]
  desc_sum_tree_merge$term <- desc_sum_tree_merge$`_name_`
  
  temp_html_plot <- collapsibleTreeNetwork(
    desc_sum_tree_merge,
    attribute = "signif",
    fill = "color", 
    nodeSize = "size",
    collapsed = FALSE,
    zoomable = FALSE
  )

  htmlwidgets::saveWidget(temp_html_plot, file=paste0(dirs$figures,"UBERON_",ids_name,"_ctn.html"))
  
  ############

  ##################
}
#c("darkblue", "blue", "#aaaaff" ,"white", "#ffaaaa",  "red","red4", "grey20"))
```


```{r, }
# library(circlepackeR)
# ##https://adeelk93.github.io/collapsibleTree/
# # Install package from CRAN:

library(collapsibleTree)
##phenotype complexity/diversity of genes -> system of affect complexity/diversity

org <- data.frame(
    Manager = c(
        NA, "Ana", "Ana", "Bill", "Bill", "Bill", "Claudette", "Claudette", "Danny",
        "Fred", "Fred", "Grace", "Larry", "Larry", "Nicholas", "Nicholas"
    ),
    Employee = c(
        "Ana", "Bill", "Larry", "Claudette", "Danny", "Erika", "Fred", "Grace",
        "Henri", "Ida", "Joaquin", "Kate", "Mindy", "Nicholas", "Odette", "Peter"
    ),
    Title = c(
        "President", "VP Operations", "VP Finance", "Director", "Director", "Scientist",
        "Manager", "Manager", "Jr Scientist", "Operator", "Operator", "Associate",
        "Analyst", "Director", "Accountant", "Accountant"
    )
)

org$Color <- org$Title
levels(org$Color) <- colorspace::rainbow_hcl(11)
collapsibleTreeNetwork(
  org,
  attribute = "Title",
  fill = "Color",
  nodeSize = "leafCount",
  collapsed = FALSE,
  zoomable=FALSE
)


species <- read.csv("https://apps.fs.usda.gov/fia/datamart/CSV/REF_SPECIES_GROUP.csv")

collapsibleTree(
  species,
  hierarchy = c("REGION", "CLASS", "NAME"),
  zoomable = F,
  fill = c(
    # The root
    "seashell",
    # Unique regions
    rep("brown", 2),rep("red",2),
    # Unique classes per region
    rep("khaki", length(unique(paste(species$REGION, species$CLASS)))),
    # Unique names per region
    rep("forestgreen", length(unique(paste(species$NAME, species$REGION))))
  )
)
```


```{r DRAFT extract protein complex associations}


### xml structure --- dissect xml in R to recapitulate each complex and it's member species
files$human_complexes <- paste0(dirs$temp_data,"human_complexes.zip")
#download.file("http://ftp.ebi.ac.uk/pub/databases/intact/complex/current/psi30/human.zip", files$human_complexes )
dirs$human_complexes <- str_remove(files$human_complexes,".zip")
#system(paste0("unzip ",files$human_complexes, " -d ", dirs$temp_data))
#system(paste0("mv ", dirs$temp_data, "human ", dirs$human_complexes))

temp_files <- list.files(dirs$human_complexes, full.names = T)
complex <- list()
i = 1
for(f in temp_files){
  if( i %% 20 ==1 ){print(paste0(basename(f),": ",i, " of ", length(temp_files)))}
  complex_metrics <- xmlParse(f)
  complex_metrics <- xmlToList(complex_metrics)
  i <- i+1
  
  complex_name <- complex_metrics$entry$interactionList$abstractInteraction$names$shortLabel
  complex_id <- paste0(complex_metrics$entry$interactionList$abstractInteraction$xref$primaryRef,collapse="__")
  complex[[complex_name]] <- list(name = complex_name,
                                  id = complex_id,
                                  members = c())
  for(interactor in complex_metrics$entry$interactorList){
    temp <- sapply(interactor$xref, function(x){paste0(x,collapse="__")} )
    temp <- temp[grep("ENSG.*gene",temp)]
    if(length(temp)==0){next}
    complex[[complex_name]]$members <- c(complex[[complex_name]]$members,
                                         str_extract(temp,"ENSG[0-9]*"))
  }  
}

### FOR EACH CHROM MODIFIER -> ID NUM OF COMPLEX SPECIES AND THEIR RESPECTIVE NUMBER OF TOTAL UNIQUE SUBUNITS ID'D
### PLOT SUMMARY DISTRIBUTION FOR ALL GENES
### BARCODE PLOT


# ggplot(df, aes(log2(transcript_length, )))+
#   geom_histogram(bins=500, alpha=0.7, fill="grey20")+
#   coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
#   barcode_theme
    #theme_bw()+


```

```{r consider gene_families level analyses }
## https://ftp.ebi.ac.uk/pub/databases/genenames/hgnc/csv/genefamily_db_tables/

```


```{r, organize datasets}

dataset_list <- list()
## encode (has uberon, standard format)

## gtex (has uberon, standard format)

## sra (mixed format)


```


```{r, read encode mouse ref RNAseq}
library(jsonlite)
library(httr)
## e10.5, e11.5, e12.5, e13.5, e14.5, e15.5, e16.5, neonat, 8wk adult, 24wk adult
## get ENCODE search results : mouse epigenome reference RNAseq
search_query <- "https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Mus+musculus&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
# 
# search_query <- "https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
query_result <- GET(search_query)
query_result <- content(query_result , "text", encoding = "UTF-8")
query_result <- fromJSON(query_result, flatten = T)
query_table <- query_result$`@graph`[!unlist(lapply(query_result$`@graph`, is.list))]

##
data_list <- list()
for(i in 1:nrow(query_table)){
  if(i %% 5 == 0){print(i)}
  target <- paste0("https://www.encodeproject.org/",
                          query_table$accession[i],
                          "/?frame=embedded&format=json")
  target <- GET(target)
  target_result <- content(target, "text", encoding = "UTF-8")
  target_result <- fromJSON(target_result, flatten = TRUE)
  temp_gene_anno <-  unique(target_result$files$genome_annotation)
  temp_gene_anno <- temp_gene_anno[grep("ENSEMBL", temp_gene_anno,invert = T)]
  which <- which(target_result$files$file_format=="tsv" &
                 target_result$files$output_type=="gene quantifications" &
                 grepl(max(as.numeric(str_remove_all(temp_gene_anno,"[a-zA-Z]")),na.rm = T),
                       target_result$files$genome_annotation) &
                 target_result$files$status == "released")
  which_cols <- c("accession", "href","biosample_ontology",
                "biological_replicates", "technical_replicates",
                "biological_replicates_formatted", "donors",
                "dataset")
  gene_quant_files <- target_result$files[which,which_cols]
  gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))] <- 
    sapply(gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))], paste )
  target_coldata <- cbind(query_table[i,], gene_quant_files)
  
  for(j in 1:nrow(target_coldata)){
    temp <- tempfile()
    download.file(paste0("https://www.encodeproject.org/",target_coldata$href[j]), temp)
    temp_data <- read.table(temp, skip = 0, header = TRUE, sep = "\t")
    data_list[[length(data_list)+1]] <- list(TPM = data.frame(TPM=temp_data$TPM),
                                             coldata = cbind(target_coldata[j,], read_count=sum(temp_data$posterior_mean_count) ) )
    rownames(data_list[[length(data_list)]]$TPM) <- temp_data$gene_id
  }
}

temp_data_list_qc <- data.frame(tpm_nrow=numeric(length=length(data_list)),
                                tpm_ncol=numeric(length=length(data_list)),
                                coldata_nrow=numeric(length=length(data_list)))
for(i in 1:length(data_list)){
  temp_data_list_qc$tpm_nrow[i] <- nrow(data_list[[i]]$TPM)
  temp_data_list_qc$tpm_ncol[i] <- ncol(data_list[[i]]$TPM)
  temp_data_list_qc$coldata_nrow[i] <- nrow(data_list[[i]]$coldata) 
}
if( nrow(unique(temp_data_list_qc)) != 1){stop("dimension mismatch between objects")}

data_list_concat <- data_list[[1]]
for(i in 2:length(data_list)){
  data_list_concat$TPM <- cbind(data_list_concat$TPM, data_list[[i]]$TPM)
  data_list_concat$coldata <- rbind(data_list_concat$coldata, data_list[[i]]$coldata)
}
data_list_concat$coldata <- as.data.frame(data_list_concat$coldata)

dataset_list$ENCODE_MM_DEV <- list(mat = data_list_concat$TPM, coldata=data_list_concat$coldata)
rm(data_list)
```


```{r, read encode human ref RNAseq}
library(jsonlite)
library(httr)

# search_query <- "https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Mus+musculus&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
# 
search_query <- "https://www.encodeproject.org/search/?type=Experiment&control_type!=*&status=released&perturbed=false&assay_title=polyA+plus+RNA-seq&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&format=json&limit=all"
#"https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
query_result <- GET(search_query)
query_result <- content(query_result , "text", encoding = "UTF-8")
query_result <- fromJSON(query_result, flatten = T)
query_table <- query_result$`@graph`[!unlist(lapply(query_result$`@graph`, is.list))]

##
data_list <- list()
for(i in 1:nrow(query_table)){
  if(i %% 5 == 0){print(i)}
  target <- paste0("https://www.encodeproject.org/",
                          query_table$accession[i],
                          "/?frame=embedded&format=json")
  target <- GET(target)
  target_result <- content(target, "text", encoding = "UTF-8")
  target_result <- fromJSON(target_result, flatten = TRUE)
  temp_gene_anno <-  unique(target_result$files$genome_annotation)
  temp_gene_anno <- temp_gene_anno[grep("ENSEMBL", temp_gene_anno,invert = T)]
  which <- which(target_result$files$file_format=="tsv" &
                 target_result$files$output_type=="gene quantifications" &
                 grepl(max(as.numeric(str_remove_all(temp_gene_anno,"[a-zA-Z]")),na.rm = T),
                       target_result$files$genome_annotation) &
                 target_result$files$status == "released")
  if(length(which)==0){next}
  which_cols <- c("accession", "href","biosample_ontology",
                "biological_replicates", "technical_replicates",
                "biological_replicates_formatted", "donors",
                "dataset")
  gene_quant_files <- target_result$files[which,which_cols]
  gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))] <- 
    sapply(gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))], paste )
  target_coldata <- cbind(query_table[i,], gene_quant_files)
  
  for(j in 1:nrow(target_coldata)){
    temp <- tempfile()
    download.file(paste0("https://www.encodeproject.org/",target_coldata$href[j]), temp)
    temp_data <- read.table(temp, skip = 0, header = TRUE, sep = "\t")
    temp_data <- temp_data[grep("PAR_Y",temp_data$gene_id, invert=T),]
    data_list[[length(data_list)+1]] <- list(TPM = data.frame(TPM=temp_data$TPM),
                                             coldata = cbind(target_coldata[j,], read_count=sum(temp_data$posterior_mean_count) ) )
    rownames(data_list[[length(data_list)]]$TPM) <- str_remove(temp_data$gene_id,"\\..*")
  }
}

temp_rownames <- character()
temp_data_list_qc <- data.frame(tpm_nrow=numeric(length=length(data_list)),
                                tpm_ncol=numeric(length=length(data_list)),
                                coldata_nrow=numeric(length=length(data_list)))
for(i in 1:length(data_list)){
  temp_data_list_qc$tpm_nrow[i] <- nrow(data_list[[i]]$TPM)
  temp_data_list_qc$tpm_ncol[i] <- ncol(data_list[[i]]$TPM)
  temp_data_list_qc$coldata_nrow[i] <- nrow(data_list[[i]]$coldata)
  temp_rownames <- unique(c(temp_rownames,rownames(data_list[[i]]$TPM)))
}
for(i in 1:length(data_list)){
  temp_missing_rownames <- setdiff(temp_rownames, rownames(data_list[[i]]$TPM))
  if(length(temp_missing_rownames)==0){next}
  temp_df <- data.frame(TPM = rep(0, length(temp_missing_rownames)))
  rownames(temp_df) <- temp_missing_rownames
  data_list[[i]]$TPM <- rbind(data_list[[i]]$TPM, temp_df)
}
for(i in 1:length(data_list)){
  temp_data_list_qc$tpm_nrow[i] <- nrow(data_list[[i]]$TPM)
  temp_data_list_qc$tpm_ncol[i] <- ncol(data_list[[i]]$TPM)
  temp_data_list_qc$coldata_nrow[i] <- nrow(data_list[[i]]$coldata)
}
#### fix dim mismatch issue for human data here ..... 
if( nrow(unique(temp_data_list_qc)) != 1){stop("dimension mismatch between objects")}

data_list_concat <- data_list[[1]]
for(i in 2:length(data_list)){
  data_list_concat$TPM <- cbind(data_list_concat$TPM, data_list[[i]]$TPM)
  data_list_concat$coldata <- rbind(data_list_concat$coldata, data_list[[i]]$coldata)
}
data_list_concat$coldata <- as.data.frame(data_list_concat$coldata)

dataset_list$ENCODE_HH <- list(mat = data_list_concat$TPM, coldata=data_list_concat$coldata)
rm(data_list)
```

```{r}
temp_onto <- ontos$uberon$ont
temp_onto$data_cols <- vector(mode = "list", length=length(temp_onto$id))
temp_ds <- dataset_list$ENCODE_MM_DEV$coldata
temp_ds <- dataset_list$ENCODE_HH$coldata

# add_annotation <- function(id, onto, annotation_name, annotation_value,
#                            propegate_to_ancestors=TRUE,
#                            propegate_from_part_to_whole=TRUE,
#                            allow_repeat_annotations=FALSE){
#   annotation_index <- which(names(onto)==annotation_name)
#   if(length(annotation_index)==0){stop(paste("annotation_name", annotation_name, "does not exist in ontology"))}
#   if(length(annotation_index)>1){stop(paste("annotation_name", annotation_name, "ambiguous in ontology"))}
#   which <- which(onto$id==id) 
#   if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
#   if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
#   
#   onto[[annotation_index]][[which]] <- c(onto[[annotation_index]][[which]], annotation_value)
#   if(!allow_repeat_annotations){
#     onto[[annotation_index]][[which]] <- unique(onto[[annotation_index]][[which]])
#   }
#   if(propegate_to_ancestors | length(onto$parents[[which]]) != 0){
#     for(parent in onto$parents[[which]]){
#       onto <- add_annotation(parent, onto, annotation_name, annotation_value,
#                              propegate_to_ancestors = propegate_to_ancestors,
#                              propegate_from_part_to_whole = propegate_from_part_to_whole,
#                              allow_repeat_annotations = allow_repeat_annotations)
#     }
#   }
#   return(onto)
# }

### cycle in is_a, part_of graph ? i.e. not a DAG?   
add_annotation <- function(id, onto, annotation_name,annotation_value,
                           transitive_relations=c("is_a","part_of"),
                           propegate_to_parents=TRUE,
                           visited_ids= c()){
  annotation_index <- which(names(onto)==annotation_name)
  if(length(annotation_index)==0){stop(paste("annotation_name", annotation_name, "does not exist in ontology"))}
  if(length(annotation_index)>1){stop(paste("annotation_name", annotation_name, "ambiguous in ontology"))}
  which <- which(onto$id==id)
  if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
  if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
  
  onto[[annotation_index]][[which]] <- unique(c(onto[[annotation_index]][[which]], annotation_value))
  ## set up and use blacklist of visited_ids
  #transitive_ids <- transitive_ids[which(transitive_ids != id)]
  visited_ids <- c(visited_ids,id)
  
  relation_df <- onto$relations[[which]]
  transitive_ids <- relation_df$id[which(is.element(relation_df$relation, transitive_relations))]
  if(propegate_to_parents){
    transitive_ids <- unique(c(transitive_ids,onto$parents[[which]]))
  }

  transitive_ids <- transitive_ids[!is.element(transitive_ids, visited_ids)]
  if(length(transitive_ids)>0){
    for( tid in transitive_ids ){
      #print(paste(onto$name[which], tid))
      onto <- add_annotation(id=tid, onto=onto, 
                             annotation_name = annotation_name,
                             annotation_value= annotation_value,
                             transitive_relations = transitive_relations,
                             propegate_to_parents = propegate_to_parents,
                             visited_ids=visited_ids )
    }
  }
  return(onto)
  
}

for(i in 1:nrow(temp_ds)){
  if(i %% 10 == 1){print(i)}
  onto_id <- str_replace(str_extract(temp_ds$biosample_ontology[i],"UBERON_[0-9]*"),"_",":")
  if(is.na(onto_id)){next}
  temp_onto <- add_annotation(onto_id, temp_onto,
                              annotation_name = "data_cols",
                              annotation_value = i,
                              transitive_relations=c("is_a","part_of"),
                              propegate_to_parents=TRUE )
  # col_id <- i
  
}

# add_inverse_relation <- function(onto, relation_to_invert, inverse_relation_name=NULL){
#   if(is.null(inverse_relation_name)){ inverse_relation_name <- paste0("INVERSE_",relation_to_invert) }
#   for(i in 1:length(onto)){
#     which(onto$relations[[i]]$relation == relation_to_invert)
#     
#   }
# }



muscle_df <- get_desc_summary_table("UBERON:0004120", temp_onto, transitive_relations = "has_part(SUPP_INVERSE)")
muscle_df$num_datasets <- sapply(str_split(muscle_df$data_cols,","), function(x){ifelse(all(x==""),0,length(x)) })
muscle_df_sub <- muscle_df[which(muscle_df$data_cols != ""),c("id","name","num_datasets","level")]
muscle_df_sub <- muscle_df_sub[order(muscle_df_sub$level),]


heart_df <- get_desc_summary_table("UBERON:0000948", temp_onto, transitive_relations = "has_part(SUPP_INVERSE)")
heart_df$num_datasets <- sapply(str_split(heart_df$data_cols,","), function(x){ifelse(all(x==""),0,length(x)) })
heart_df_sub <- heart_df[which(heart_df$data_cols != ""),c("id","name","num_datasets","level")]
heart_df_sub <- heart_df_sub[order(heart_df_sub$level),]

write.csv(muscle_df_sub, paste0(dirs$tables,"ENCODE_mesoderm_derived_RNAseq.csv"))
write.csv(heart_df_sub, paste0(dirs$tables,"ENCODE_heart_RNAseq.csv"))

```
