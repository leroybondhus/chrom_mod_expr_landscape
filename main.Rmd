---
title: "main"
output: html_document
date: "2023-01-27"
author: "Leroy Bondhus"
---

```{r set up dir structure}
                         
dirs <- list(data="./data/",
             results = "./results/",
             tables = "./results/tables/",
             figures = "./results/figures/",
             temp_data ="/u/scratch/l/leroybon/chrom_mod_expr_landscape/",
             OMIM_data = "./data/omim_ra/")
for(dir in dirs){
  if(!dir.exists(dir)){dir.create(dir)}
};rm(dir)

files <- list()

####
date <- format(Sys.time(),"%Y%m%d")
```

```{r setup note}
#### NOTE : USER HAS TO REQUEST ACCESS TO A LINK FROM OMIM DIRECTLY TO GET THIS FILE #####
####        ONCE THIS IS DONE REPLACE "NULL" BELOW WITH THE URL TO genemap2.txt FILE #####

#OMIM_genemap2_URL <- "https://data.omim.org/downloads/##USER_ACCESS_PATTERN##/genemap2.txt"
OMIM_genemap2_URL <- NULL
#if(is.null(OMIM_genemap2_URL){rm(OMIM_genemap2_URL)}
####                                     END NOTE                                    #####

files$OMIM_GENE <- paste0(dirs$OMIM_data,"HPO_genes_to_phenotypes.txt")
if(!file.exists(files$OMIM_GENE)){
  if(!exists("OMIM_genemap2_URL")){
    stop(paste0( "Please visit https://www.omim.org/downloads and follow instructions to get URL link ",
                 "for 'genemap2.txt', then set OMIM_genemap2_URL variable to this link in this script " ))
  }
  download.file(OMIM_genemap2_URL, files$OMIM_GENE)
}
     
```

```{r load libraries}
req_packages <- list(
  standard = c("BiocManager","doParallel","ggplot2","stringr", "reshape2", "XML"),
  biocmanager = c("Gviz","biomaRt")
)
for(std_package in req_packages$standard ){
  if(!require(std_package, quietly=T, character.only=T)){install.packages(std_package)}
};rm(std_package)
for(bioc_package in req_packages$biocmanager ){
  if(!require(bioc_package, quietly=T, character.only=T)){BiocManager::install(bioc_package)}
};rm(bioc_package)
rm(req_packages)
```


```{r, ontos helper functions}
## assume ontology is list of elements of equal length
## elements must include "id", "name", "parents", "children"

add_children_from_parents <- function(onto){
  for(i in 1:length(onto$id)){
    if(length(onto$parents[[i]])<1){next}
    which <- which(is.element(onto$id, onto$parents[[i]]))
    for(j in which){
      onto$children[[j]] <- c(onto$children[[j]], onto$id[i])
    }
  }
  return(onto)
}

get_descendants <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$children[[which]]) == 0){
    return(onto$id[which])
  }
  descendants <- id
  for(child in onto$children[[which]]){
    descendants <- unique(c(descendants, get_descendants(child, onto)))
  }
  return(descendants)
}

get_ancestors <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$parents[[which]]) == 0){
    return(onto$id[which])
  }
  ancestors <- id
  for(parent in onto$parents[[which]]){
    ancestors <- unique(c(ancestors, get_ancestors(parent, onto)))
  }
  return(ancestors)
}

get_height <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$children[[which]]) == 0){
    return(1)
  }
  max_child_height <- 0
  for(child in onto$children[[which]]){
    max_child_height <- max(max_child_height, get_height(child, onto))
  }
  return(max_child_height+1)
}

get_depth <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$parents[[which]]) == 0){
    return(1)
  }
  max_parent_depth <- 0
  for(parent in onto$parents[[which]]){
    max_parent_depth <- max(max_parent_depth, get_depth(parent, onto))
  }
  return(max_parent_depth+1)
}

get_mask_set <- function(id, onto){ #}, mask_self=T){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(onto$is_signif[which] ){
    return(onto$id[which]) ## if signif, end recursion down since don't need to also mask descendants
  } else {
    mask_set <- character(length=0)
  }
  if(length(onto$children[[which]]) > 0){ 
    for(child in onto$children[[which]]){
      mask_set <- c(mask_set, get_mask_set(child,onto)) # ,mask_self=F)) 
    }
  }
  return(unique(mask_set))
}
```

```{r, organize ontologies}


ontos <- list()
ontos$go = list(
  URL = "http://purl.obolibrary.org/obo/go.obo"
)

files$go_obo <- paste0(dirs$temp_data,"go.obo")
download.file(ontos$go$URL,files$go_obo)

##### read in and set up ontology ####
con <- file(files$go_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^\\[Term\\]$",line)
}
close(con)

ontos$go$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
con <- file(files$go_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    term_num <- term_num + 1
  } else if(grepl("^id:.*GO:",line)){
    ontos$go$ont$id[term_num] <- str_extract(line, "GO:[0-9]+")
  } else if(grepl("^name:",line)){
    ontos$go$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^namespace:",line)){
    ontos$go$ont$namespace[term_num] <- str_remove(line, "^namespace:[[:space:]]")
  } else if(grepl("^is_a:",line)){
    ontos$go$ont$parents[term_num][[1]] <- c(ontos$go$ont$parents[term_num][[1]], str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line)){
    ontos$go$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con)

### replace is_a with parents
### add children attribute to each term for ease of navigation up and down ontology
ontos$go$ont <- add_children_from_parents(ontos$go$ont)

##### done: read in and set up ontology ####





## uberon
## hpo
ontos$hpo <- list()
ontos$hpo$URL <- "https://github.com/obophenotype/human-phenotype-ontology/raw/master/hp.obo"

files$hp_obo <- paste0(dirs$temp_data,"hp.obo")
download.file(ontos$hpo$URL,files$hp_obo)


con <- file(files$hp_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^\\[Term\\]$",line)
}
close(con)

ontos$hpo$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
#  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
con <- file(files$hp_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    term_num <- term_num + 1
  } else if(grepl("^id:.*HP:",line)){
    ontos$hpo$ont$id[term_num] <- str_extract(line, "HP:[0-9]+")
  } else if(grepl("^name:",line)){
    ontos$hpo$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^is_a:",line)){
    ontos$hpo$ont$parents[term_num][[1]] <- c(ontos$hpo$ont$parents[term_num][[1]], str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line)){
    ontos$hpo$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con)
ontos$hpo$ont <- add_children_from_parents(ontos$hpo$ont)


## set up uberon ontology ###
ontos$uberon <- list()
ontos$uberon$URL <- "https://github.com/obophenotype/uberon/releases/download/v2023-02-14/uberon-full.obo"

files$uberon_obo <- paste0(dirs$temp_data,"uberon-full.obo")
download.file(ontos$uberon$URL,files$uberon_obo)


con <- file(files$uberon_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^id:.*UBERON:",line)
}
close(con)

ontos$uberon$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
#  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  relations = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
is_uberon <- FALSE
con <- file(files$uberon_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    is_uberon <- FALSE
  } else if(grepl("^id:.*UBERON:",line)){
    term_num <- term_num + 1
    ontos$uberon$ont$id[term_num] <- str_extract(line, "UBERON:[0-9]+")
    is_uberon <- TRUE
  } else if(grepl("^name:",line) & is_uberon){
    ontos$uberon$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^is_a:.*UBERON",line) & is_uberon){
    ontos$uberon$ont$parents[term_num][[1]] <- c(ontos$uberon$ont$parents[term_num][[1]],
                                                 #str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*"))
                                                 str_extract(line, "UBERON:[0-9]*"))
  } else if(grepl("^relationship:.*UBERON",line) & is_uberon){
    temp_relation  <- str_remove(str_remove(line, "^relationship:[[:space:]]"),"[[:space:]]*!.*")
    temp_df <- data.frame(relation = str_remove(temp_relation, " .*"),
                          id = str_extract(temp_relation, "UBERON:[0-9]+"))
    ontos$uberon$ont$relations[term_num][[1]] <- rbind(ontos$uberon$ont$relations[term_num][[1]],
                                                       temp_df) 
      # c(ontos$uberon$ont$parents[term_num][[1]],
      # str_remove(str_remove(line, "^relationship:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line) & is_uberon){
    ontos$uberon$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con)
ontos$uberon$ont <- add_children_from_parents(ontos$uberon$ont)


```



```{r, organize onto_maps}
onto_maps <- list()
onto_maps$OMIM_GENE <- list()

##### read in and set up MIM gene to disease database (aka map) ####
con <- file(files$OMIM_GENE,open="r")
temp_header <- readLines(con, 4)[4]
temp_header <- str_remove(temp_header,"# ")
temp_header <- str_split_1(temp_header,"\t")
close(con)
onto_maps$OMIM_GENE$map <- read.delim2(files$OMIM_GENE, header=FALSE, comment.char="#")
colnames(onto_maps$OMIM_GENE$map) <- str_replace_all(temp_header,"[[:space:]]","_")
onto_maps$OMIM_GENE$map <- onto_maps$OMIM_GENE$map[complete.cases(onto_maps$OMIM_GENE$map),]
### FURTHER PARSING NECESSARY: COLUMN "Phenotypes" contains actual phenotype OMIM ID, MIM_Number is for gene's mim number...
###                            for "Phenotypes" column, only use those associated with (3) which indicates gene found causative
onto_maps$OMIM_GENE$map <- onto_maps$OMIM_GENE$map[,c("Ensembl_Gene_ID","Phenotypes")]

temp <- str_split(onto_maps$OMIM_GENE$map$Phenotypes,";")
names(temp) <- onto_maps$OMIM_GENE$map$Ensembl_Gene_ID
temp <- melt(temp); colnames(temp) <- c("Phenotype","Ensembl_Gene_ID")
temp$temp_str <- str_extract(temp$Phenotype,"[0-9]{6}.*\\([0-4]\\).*")
temp$evidence_code <- str_extract(temp$temp_str,"\\([0-4]\\)")
temp$inheritance_mode <- str_extract(temp$temp_str,"[a-zA-Z].*")
temp$OMIM_ID <- str_extract(temp$temp_str,"[0-9]{6}")
temp$temp_str <- NULL
temp$Phenotype <-  str_remove(temp$Phenotype,", [0-9]{6}.*")

onto_maps$OMIM_GENE$map <- temp

onto_maps$HPO_OMIM <- list()
##### try other file......
onto_maps$HPO_OMIM$URL <- "http://purl.obolibrary.org/obo/hp/hpoa/phenotype.hpoa"
files$HPO_OMIM <- paste0(dirs$temp_data,"phenotype.hpoa")
download.file(onto_maps$HPO_OMIM$URL, files$HPO_OMIM)
### column descriptors https://hpo-annotation-qc.readthedocs.io/en/latest/annotationFormat.html#phenotype-hpoa-format
##### read in and set up HPO gene to phenotype map ####
onto_maps$HPO_OMIM$map <- read.csv(files$HPO_OMIM,sep="\t",skip=4)
onto_maps$HPO_OMIM$map <- onto_maps$HPO_OMIM$map[grepl("OMIM",onto_maps$HPO_OMIM$map$database_id),]
colnames(onto_maps$HPO_OMIM$map)[which(colnames(onto_maps$HPO_OMIM$map)=="database_id")] <- "OMIM_ID"
colnames(onto_maps$HPO_OMIM$map)[which(colnames(onto_maps$HPO_OMIM$map)=="hpo_id")] <- "HPO_ID"


onto_maps$HPO_OMIM_GENE <- list()
temp1 <- onto_maps$HPO_OMIM$map[,c("OMIM_ID","HPO_ID")]
temp2 <- onto_maps$OMIM_GENE$map[c("Ensembl_Gene_ID","OMIM_ID")]
temp2$OMIM_ID <- paste0("OMIM:",temp2$OMIM_ID)
onto_maps$HPO_OMIM_GENE$map <- merge(temp1,temp2)



### HPO to UBERON
## hpo
onto_maps$HPO_UBERON <- list()
onto_maps$HPO_UBERON$URL <- "http://purl.obolibrary.org/obo/hp.owl"

files$hp_owl <- paste0(dirs$temp_data,"hp.owl")
download.file(onto_maps$HPO_UBERON$URL,files$hp_owl)


con <- file(files$hp_owl,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("<!--.*HP_",line)
}
close(con)

onto_maps$HPO_UBERON$map <- list(
  HPO_id=character(length = num_terms ),
  UBERON_terms = vector("list", num_terms)
)

term_num <- 0
on_HPO_term <- FALSE
con <- file(files$hp_owl,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("<!--.*HP_",line)){
    term_num <- term_num + 1
    onto_maps$HPO_UBERON$map$HPO_id[term_num] <- str_extract(line, "HP_[0-9]+")
    on_HPO_term <- TRUE
  } else if(grepl("UBERON",line) & on_HPO_term){
    onto_maps$HPO_UBERON$map$UBERON_terms[[term_num]] <- c(onto_maps$HPO_UBERON$map$UBERON_terms[[term_num]], 
                                                        str_extract(line, "UBERON_[0-9]+"))
  } else if(grepl("<!--",line)){
    on_HPO_term <- FALSE
  }
}
close(con)

onto_maps$HPO_UBERON$map$UBERON_terms[sapply(onto_maps$HPO_UBERON$map$UBERON_terms, is.null)] <- NA 
names(onto_maps$HPO_UBERON$map$UBERON_terms) <- onto_maps$HPO_UBERON$map$HPO_id
temp <- reshape2::melt(onto_maps$HPO_UBERON$map$UBERON_terms)
colnames(temp) <- c("UBERON_ID","HPO_ID")
temp$UBERON_ID <- str_replace_all(temp$UBERON_ID, "_",":")
temp$HPO_ID <- str_replace_all(temp$HPO_ID,"_",":")
onto_maps$HPO_UBERON$map <- temp[,c("HPO_ID","UBERON_ID")]





```


```{r, organize gene sets}
ensembl <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
options(timeout=300)
gene_sets <- list()
### these pulls are fairly time intensive -> consider saving to data in short term and load if exists
gene_sets$genes_all <- getBM(attributes=c('ensembl_gene_id',"external_gene_name",
                                          "start_position","end_position"),
                 mart = ensembl, useCache = F)

## alternatively download from: http://geneontology.org/gene-associations/goa_human.gaf.gz
for(chr in c(as.character(1:22),"X","Y","MT" )){
  temp <- getBM(attributes=c('ensembl_gene_id',"external_gene_name",
                             "ensembl_transcript_id","transcript_length",
                             "chromosome_name", "exon_chrom_start","exon_chrom_end","rank"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  temp2 <- getBM(attributes=c('ensembl_gene_id',
                             "ensembl_transcript_id",
                             "transcript_is_canonical"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  temp <- merge(temp, temp2)
  gene_sets$genes_all_transcript <- rbind(gene_sets$genes_all_transcript, temp)
  
  temp <- getBM(attributes=c('ensembl_gene_id',"external_gene_name","go_id","name_1006"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  gene_sets$genes_all_go <- rbind(gene_sets$genes_all_go, temp)
  
}
gene_sets$genes_all_transcript <- gene_sets$genes_all_transcript[which(!is.na(gene_sets$genes_all_transcript$transcript_is_canonical)),]

gene_sets$human_chromatin_modifiers <- list()
gene_sets$human_chromatin_modifiers$go_terms = c( "histone acetyltransferase activity",
                                        "histone deacetylase activity",
                                        "histone methyltransferase activity",
                                        "histone demethylase activity",
                                        "histone ubiquitin ligase activity",
                                        "histone deubiquitinase activity",
                                        "histone kinase activity",
                                        "histone phosphatase activity",
                                      ##  "chromatin remodeling", too broad
                                      ##  "chromatin organization", too broad
                                        "nucleosome organization",
                                        "chromatin looping",
                                        "heterochromatin organization",
                                        "DNA-methyltransferase activity",
                                        "DNA demethylase activity")


## for each term in chrom_go_terms, check which genes are associated with term (and any of it's descendants)
#### for each term, get all descendant terms
go_funcs <- list()
go_funcs$get_descendants <- function(id,go){
  which <- which(go$id == id)
  descendants <- go$id[which] ### a term is considered a descendant of itself
  if( length(go$children[[which]])==0 ){return(descendants)}
  for(child in go$children[[which]]){
    descendants <- unique(c(descendants, go_funcs$get_descendants(child, go) ))
  }
  return(descendants)
}

gene_sets$human_chromatin_modifiers$go_ids <- character(length = length(gene_sets$human_chromatin_modifiers$go_terms))
gene_sets$human_chromatin_modifiers$gene_subsets <- vector("list",length(gene_sets$human_chromatin_modifiers$go_terms))
names(gene_sets$human_chromatin_modifiers$gene_subsets ) <- gene_sets$human_chromatin_modifiers$go_terms
for(i in 1:length(gene_sets$human_chromatin_modifiers$go_terms)){
  ## which go onto node has the current term
  which <- which(ontos$go$ont$name == gene_sets$human_chromatin_modifiers$go_terms[i])
  term_id <- ontos$go$ont$id[which]
  gene_sets$human_chromatin_modifiers$go_ids[i] <- term_id
  
  ## genes which have GO id for current term or any of it's descendants
  descendants <- go_funcs$get_descendants(term_id, ontos$go$ont)
  gene_sets$human_chromatin_modifiers$gene_subsets[[i]] <-
    unique(gene_sets$genes_all_go$ensembl_gene_id[which(is.element(gene_sets$genes_all_go$go_id, descendants ))])
  
}

gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers <- unique(unlist(gene_sets$human_chromatin_modifiers$gene_subsets))


## human
## mouse
## zebrafish
## celegans
## fly 
## chromatin modifier


```

```{r, custom ggplot themes}
barcode_theme <- theme_classic()+
  theme(axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y  = element_blank(),
        axis.ticks.y = element_blank()
  )


```

```{r, look at basic chromatin modifier summary statistics}

## gene length
## transcript length
## exon count
## exon size
ggl <- list()
for(i in 14){ #  1:length(gene_sets$human_chromatin_modifiers$gene_subsets)){
  chrom_subset <- gene_sets$human_chromatin_modifiers$gene_subsets[[i]] 
  chrom_subset_name <- names(gene_sets$human_chromatin_modifiers$gene_subsets)[i]
  if(length(chrom_subset)==0){next}
  ## gene length density + barcode plots
  df <- gene_sets$genes_all[which(is.element(gene_sets$genes_all$ensembl_gene_id, chrom_subset )),]
  df$gene_length <- df$end_position - df$start_position
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length density")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(gene_length)))+
    ggtitle(temp_name)+
    geom_density(alpha=0.5)
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length barcode")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(gene_length),xend=log10(gene_length), y=0,yend=1))+
    ggtitle(temp_name)+
    geom_segment(alpha=0.5)+
    coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
    barcode_theme
  
  ## transcript length density + barcode plot
  df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, chrom_subset )),]
  df <- unique(df[,c("ensembl_gene_id", "transcript_length")])
  
  temp_name <- paste0(chrom_subset_name, ": ", "transcript_length density")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(transcript_length)))+
    ggtitle(temp_name)+
    geom_density(alpha=0.5)
  
  temp_name <- paste0(chrom_subset_name, ": ", "transcript_length barcode")
  ggl[[temp_name]] <-  ggplot(df, aes(x=log10(transcript_length),xend=log10(transcript_length), y=0,yend=1))+
    ggtitle(temp_name)+
    geom_segment(alpha=0.5)+
    coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
    barcode_theme
   
  
  
  ## exon length  plot
  df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, chrom_subset )),]
  #df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, sample(unique(gene_sets$genes_all$ensembl_gene_id),45) )),]
  df$exon_length <- df$exon_chrom_end - df$exon_chrom_start
  df$gene_factor_num <- as.numeric(as.factor(df$ensembl_gene_id))
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(exon_length),y=gene_factor_num))+
    ggtitle(temp_name)+
    geom_point(fill="grey20") +
    coord_cartesian( xlim = c(1, 4))+
    barcode_theme
  
  
  ## exon count plot
  temp_df <- as.data.frame(table(df$ensembl_transcript_id))
  colnames(temp_df)[1] <- "ensembl_transcript_id"
  colnames(temp_df)[2] <- "exon_count"
  df <- merge(df, temp_df, sort=FALSE)
  
  ## test 2d plot of exon count by min size
  
  temp <- split(df$exon_length, df$ensembl_transcript_id)
  temp <- sapply(temp, function(x) rank(-x, ties.method = "last"))
  df$exon_length_rank <- unsplit(temp, df$ensembl_transcript_id)
  
  temp <- split(df$exon_length, df$exon_length_rank) 
  temp <- sapply(temp, sort, decreasing=T)
  temp <- melt(temp)
  temp2 <- split(temp$value, temp$L1)
  num_genes <- length(unique(df$ensembl_gene_id))
  temp2 <- sapply(temp2, function(x) (1:length(x))/num_genes )
  temp2 <- unsplit(temp2, temp$L1)
  temp$percentile <- temp2
  temp$L1 <- as.numeric(temp$L1)
  temp <- temp[order(temp$L1, temp$percentile),]
  temp$L1 <- as.factor(temp$L1)
  colnames(temp) <- c("exon_length","exon_rank_by_length","percentile")
  temp_name <- paste0(chrom_subset_name, ": ", "genes_w_N_exons_of_size_or_greater")
  ggl[[temp_name]] <- ggplot(temp, aes(log10(exon_length), percentile, group=exon_rank_by_length, color=exon_rank_by_length))+
    ggtitle(temp_name)+
    geom_line()
  
  temp <- split(df$rank, df$ensembl_transcript_id)
  temp <-sapply(temp, function(x) order(-x))
  temp <- unsplit(temp, df$ensembl_transcript_id)
  df$rank_from_end <- temp
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length v rank")
  ggl[[temp_name]] <- ggplot(df, aes(rank, log10(exon_length) ))+
    ggtitle(temp_name)+
    geom_point(alpha=0.5)
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length v rank_from_end")
  ggl[[temp_name]] <- ggplot(df, aes(rank_from_end, log10(exon_length) ))+
    ggtitle(temp_name)+
    geom_point(alpha=0.5)
  
}

dirs$gene_arch_summary_figs <- paste0(dirs$figures,"gene_arch_summary_figures/")
if(!dir.exists(dirs$gene_arch_summary_figs)){dir.create(dirs$gene_arch_summary_figs)}
for(i in 1:length(ggl)){
  
  temp_filename <- paste0(dirs$gene_arch_summary_figs,names(ggl)[i],".png")
  temp_filename <- str_replace_all(temp_filename,"[ \t:]","_")
  w <- 7
  h <- ifelse(grepl("barcode", temp_filename), 3, 5)
  ggsave(temp_filename, ggl[[i]], device = "png", width=w, height=h)
}

```

```{r, look at basic disease association statistics }

### look at pLI

temp <- tempfile()
download.file("https://storage.googleapis.com/gcp-public-data--gnomad/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz",temp)
lof_metrics <- read.table( temp, skip=0, header = TRUE, sep = "\t")

temp <- tempfile()
download.file("http://geneontology.org/gene-associations/goa_human_complex.gaf.gz",temp)
go_complex_metrics <- read.table( temp, skip=0, header = TRUE, sep = "\t")

ggl2 <- list()
for(i in 14){ #  1:length(gene_sets$human_chromatin_modifiers$gene_subsets)){
  chrom_subset <- gene_sets$human_chromatin_modifiers$gene_subsets[[i]] 
  chrom_subset_name <- names(gene_sets$human_chromatin_modifiers$gene_subsets)[i]
  if(length(chrom_subset)==0){next}
  
  df <- lof_metrics[which(is.element(lof_metrics$gene_id, chrom_subset)),] 
  id_cols <- c("gene","gene_id","gene_type")
  var_cols <- c("oe_mis","oe_syn","oe_lof","no_lofs","obs_het_lof","obs_hom_lof", "pLI","oe_lof_upper","syn_z","mis_z","lof_z")
  df_melt <- melt(df, id.vars=id_cols, measure.vars = var_cols)
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length density")
  ggplot(df_melt[grep("oe", df_melt$variable),],aes(x=variable, y=value))+
    geom_violin() 
  ggplot(df_melt[grep("_z", df_melt$variable),],aes(x=variable, y=value))+
    geom_violin()
  ggplot(df_melt[grep("pLI", df_melt$variable),],aes(y=value))+
    geom_histogram()
  ggplot(df_melt[grep("oe_lof_upper", df_melt$variable),],aes(y=value))+
    geom_histogram()
  
  
  ### GET all associated with Mendelian disorder (e.g. v pLI)

}


## for each HPO, test enrichment of chrom modifiers in set
## plot by signif and OR, add labels (padj by bonferroni)



which <- which(is.element(onto_maps$HPO_OMIM_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- onto_maps$HPO_OMIM_GENE$map[which,]
temp_not_chrom <- onto_maps$HPO_OMIM_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
temp_res_df <- data.frame(p.value=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio_lb=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio_ub=numeric(length(ontos$hpo$ont$id)))

for(i in 1:length(ontos$hpo$ont$id)){
  if(i %% 1000 == 1){print(i)}
  hps <- get_descendants(ontos$hpo$ont$id[i], ontos$hpo$ont)
  
  which <- which(is.element(temp_chrom$HPO_ID, hps))
  temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <- which(is.element(temp_not_chrom$HPO_ID, hps))
  temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

    ### Use all genes or only those with some HP association ?
  which <-  which(!is.element(temp_chrom$HPO_ID, hps))
  temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
  temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
  ## chrom and hp
  
  ## chrom and not hp
  ## not chrom and hp
  ## not chrom and not hp
  
  temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                  c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
  
  ## Odds Ratio
  temp_res_df$p.value[i] <- temp_res$p.value
  temp_res_df$odds_ratio[i] <- temp_res$estimate
  temp_res_df$odds_ratio_lb[i] <- temp_res$conf.int[1]
  temp_res_df$odds_ratio_ub[i] <- temp_res$conf.int[2]
}


## plot Gene-Gene phenotype similarity (asymetric if want subsumption test e.g.  if A has subset of phens of B)
## subsumption test may be useful later if make meta-genes by aggregation of complex components..... 

```

```{r, experimental ontology layered analysis}

which <- which(is.element(onto_maps$HPO_OMIM_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- onto_maps$HPO_OMIM_GENE$map[which,]
temp_not_chrom <- onto_maps$HPO_OMIM_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
onto <- ontos$hpo$ont

onto$height <- numeric(length=length(onto$id))
onto$depth <- numeric(length=length(onto$id))
for(i in 1:length(onto$id)){
  if(i %% 500 == 0){print(i)}
  onto$height[i] <- get_height(onto$id[i],onto)
  onto$depth[i] <- get_depth(onto$id[i],onto)
}


onto$is_signif <- rep(F,length(onto$id))
for( layer in 1:max(onto$height)){
  print(paste0("layer is: ",layer ))
  els_in_layer <- which(onto$height==layer)
  i = 1
  for( el in els_in_layer ){
    if(i %% 250 == 0){print(i)}
    i <- i+1
    hps <- get_descendants(onto$id[el], onto)
  
    which <- which(is.element(temp_chrom$HPO_ID, hps))
    temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <- which(is.element(temp_not_chrom$HPO_ID, hps))
    temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
      ### Use all genes or only those with some HP association ?
    which <-  which(!is.element(temp_chrom$HPO_ID, hps))
    temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
    temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
    
    temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                  c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
    
    is_signif <- temp_res$p.value < 0.05
    if(!is_signif){next}
    ## get list of signif children - these form the mask set.. 
    ## actually.. probs want all signif descendants? Probs don't
    ## need to deal with children of signif children, but children of
    ## insignif children may themselves have substantial signal/ be signif...
    ## and then drive association at later ancestor level.. 
    
    #children_subset <- which(is.element(onto$id, onto$children[[el]]))
    
    # children_subset <- which(is.element(onto$id, get_descendants(onto$id[el],onto)))
    # 
    # which_children_signif <- children_subset[which(onto$is_signif[children_subset])]
    # signif_children <- onto$id[which_children_signif] 
    # signif_children <- signif_children[which(!is.element(signif_children,onto$id[el]))] # remove _self_ from descendants
    
    signif_children <- get_mask_set(onto$id[el], onto)
    
    if(length(signif_children>0)){ ### replace with children that are already called as significant only
      for( child in signif_children){
        hps <- onto$id[el] ## want to retain any that are directly associated with _self_.. 
        ## NOTE: Don't want to retain _self_ in hps if database includes redundant associations.. i.e. database should
        ## only include most specific instance and NOT also all ancestors of that instance ..
        for( other_child in signif_children){
          if( other_child == child){next}
          hps <- c(hps, get_descendants(other_child, onto))
        } 
  
        which <- which(is.element(temp_chrom$HPO_ID, hps))
        temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <- which(is.element(temp_not_chrom$HPO_ID, hps))
        temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
      
          ### Use all genes or only those with some HP association ?
        which <-  which(!is.element(temp_chrom$HPO_ID, hps))
        temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
        temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
        
        temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                      c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
        is_signif <- temp_res$p.value < 0.05 
        if(!is_signif){break}
      }
      
    }
    onto$is_signif[el] <- is_signif
  }
}
save.image()

layer_df <- list()
for( i in 1:max(onto$depth)){
  which <- which(onto$depth==i & onto$is_signif)
  if(length(which) < 1){ next}
  for(id in onto$id[which]){
    ancestors <- get_ancestors(id, onto)
    ancestors <- ancestors[which(ancestors != id)]
    
  }
}

```

```{r, }
##phenotype complexity/diversity of genes -> system of affect complexity/diversity
```


```{r DRAFT extract protein complex associations}


### xml structure --- dissect xml in R to recapitulate each complex and it's member species
files$human_complexes <- paste0(dirs$temp_data,"human_complexes.zip")
#download.file("http://ftp.ebi.ac.uk/pub/databases/intact/complex/current/psi30/human.zip", files$human_complexes )
dirs$human_complexes <- str_remove(files$human_complexes,".zip")
#system(paste0("unzip ",files$human_complexes, " -d ", dirs$temp_data))
#system(paste0("mv ", dirs$temp_data, "human ", dirs$human_complexes))

temp_files <- list.files(dirs$human_complexes, full.names = T)
complex <- list()
i = 1
for(f in temp_files){
  if( i %% 20 ==1 ){print(paste0(basename(f),": ",i, " of ", length(temp_files)))}
  complex_metrics <- xmlParse(f)
  complex_metrics <- xmlToList(complex_metrics)
  i <- i+1
  
  complex_name <- complex_metrics$entry$interactionList$abstractInteraction$names$shortLabel
  complex_id <- paste0(complex_metrics$entry$interactionList$abstractInteraction$xref$primaryRef,collapse="__")
  complex[[complex_name]] <- list(name = complex_name,
                                  id = complex_id,
                                  members = c())
  for(interactor in complex_metrics$entry$interactorList){
    temp <- sapply(interactor$xref, function(x){paste0(x,collapse="__")} )
    temp <- temp[grep("ENSG.*gene",temp)]
    if(length(temp)==0){next}
    complex[[complex_name]]$members <- c(complex[[complex_name]]$members,
                                         str_extract(temp,"ENSG[0-9]*"))
  }  
}

### FOR EACH CHROM MODIFIER -> ID NUM OF COMPLEX SPECIES AND THEIR RESPECTIVE NUMBER OF TOTAL UNIQUE SUBUNITS ID'D
### PLOT SUMMARY DISTRIBUTION FOR ALL GENES
### BARCODE PLOT


# ggplot(df, aes(log2(transcript_length, )))+
#   geom_histogram(bins=500, alpha=0.7, fill="grey20")+
#   coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
#   barcode_theme
    #theme_bw()+


```



```{r, organize datasets}

dataset_list <- list()
## encode (has uberon, standard format)

## gtex (has uberon, standard format)

## sra (mixed format)


```


```{r, read encode mouse ref RNAseq}
library(jsonlite)
library(httr)
## e10.5, e11.5, e12.5, e13.5, e14.5, e15.5, e16.5, neonat, 8wk adult, 24wk adult
## get ENCODE search results : mouse epigenome reference RNAseq
search_query <- "https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Mus+musculus&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
# 
# search_query <- "https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
query_result <- GET(search_query)
query_result <- content(query_result , "text", encoding = "UTF-8")
query_result <- fromJSON(query_result, flatten = T)
query_table <- query_result$`@graph`[!unlist(lapply(query_result$`@graph`, is.list))]

##
data_list <- list()
for(i in 1:nrow(query_table)){
  if(i %% 5 == 0){print(i)}
  target <- paste0("https://www.encodeproject.org/",
                          query_table$accession[i],
                          "/?frame=embedded&format=json")
  target <- GET(target)
  target_result <- content(target, "text", encoding = "UTF-8")
  target_result <- fromJSON(target_result, flatten = TRUE)
  temp_gene_anno <-  unique(target_result$files$genome_annotation)
  temp_gene_anno <- temp_gene_anno[grep("ENSEMBL", temp_gene_anno,invert = T)]
  which <- which(target_result$files$file_format=="tsv" &
                 target_result$files$output_type=="gene quantifications" &
                 grepl(max(as.numeric(str_remove_all(temp_gene_anno,"[a-zA-Z]")),na.rm = T),
                       target_result$files$genome_annotation) &
                 target_result$files$status == "released")
  which_cols <- c("accession", "href","biosample_ontology",
                "biological_replicates", "technical_replicates",
                "biological_replicates_formatted", "donors",
                "dataset")
  gene_quant_files <- target_result$files[which,which_cols]
  gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))] <- 
    sapply(gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))], paste )
  target_coldata <- cbind(query_table[i,], gene_quant_files)
  
  for(j in 1:nrow(target_coldata)){
    temp <- tempfile()
    download.file(paste0("https://www.encodeproject.org/",target_coldata$href[j]), temp)
    temp_data <- read.table(temp, skip = 0, header = TRUE, sep = "\t")
    data_list[[length(data_list)+1]] <- list(TPM = data.frame(TPM=temp_data$TPM),
                                             coldata = cbind(target_coldata[j,], read_count=sum(temp_data$posterior_mean_count) ) )
    rownames(data_list[[length(data_list)]]$TPM) <- temp_data$gene_id
  }
}

temp_data_list_qc <- data.frame(tpm_nrow=numeric(length=length(data_list)),
                                tpm_ncol=numeric(length=length(data_list)),
                                coldata_nrow=numeric(length=length(data_list)))
for(i in 1:length(data_list)){
  temp_data_list_qc$tpm_nrow[i] <- nrow(data_list[[i]]$TPM)
  temp_data_list_qc$tpm_ncol[i] <- ncol(data_list[[i]]$TPM)
  temp_data_list_qc$coldata_nrow[i] <- nrow(data_list[[i]]$coldata) 
}
if( nrow(unique(temp_data_list_qc)) != 1){stop("dimension mismatch between objects")}

data_list_concat <- data_list[[1]]
for(i in 2:length(data_list)){
  data_list_concat$TPM <- cbind(data_list_concat$TPM, data_list[[i]]$TPM)
  data_list_concat$coldata <- rbind(data_list_concat$coldata, data_list[[i]]$coldata)
}
data_list_concat$coldata <- as.data.frame(data_list_concat$coldata)

dataset_list$ENCODE_MM_DEV <- list(mat = data_list_concat$TPM, coldata=data_list_concat$coldata)
rm(data_list)
```


```{r, read encode human ref RNAseq}
library(jsonlite)
library(httr)

# search_query <- "https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Mus+musculus&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
# 
search_query <- "https://www.encodeproject.org/search/?type=Experiment&control_type!=*&status=released&perturbed=false&assay_title=polyA+plus+RNA-seq&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&format=json&limit=all"
#"https://www.encodeproject.org/search/?type=Experiment&related_series.@type=ReferenceEpigenome&status=released&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&assay_title=polyA+plus+RNA-seq&frame=object&format=json&limit=all"
query_result <- GET(search_query)
query_result <- content(query_result , "text", encoding = "UTF-8")
query_result <- fromJSON(query_result, flatten = T)
query_table <- query_result$`@graph`[!unlist(lapply(query_result$`@graph`, is.list))]

##
data_list <- list()
for(i in 1:nrow(query_table)){
  if(i %% 5 == 0){print(i)}
  target <- paste0("https://www.encodeproject.org/",
                          query_table$accession[i],
                          "/?frame=embedded&format=json")
  target <- GET(target)
  target_result <- content(target, "text", encoding = "UTF-8")
  target_result <- fromJSON(target_result, flatten = TRUE)
  temp_gene_anno <-  unique(target_result$files$genome_annotation)
  temp_gene_anno <- temp_gene_anno[grep("ENSEMBL", temp_gene_anno,invert = T)]
  which <- which(target_result$files$file_format=="tsv" &
                 target_result$files$output_type=="gene quantifications" &
                 grepl(max(as.numeric(str_remove_all(temp_gene_anno,"[a-zA-Z]")),na.rm = T),
                       target_result$files$genome_annotation) &
                 target_result$files$status == "released")
  if(length(which)==0){next}
  which_cols <- c("accession", "href","biosample_ontology",
                "biological_replicates", "technical_replicates",
                "biological_replicates_formatted", "donors",
                "dataset")
  gene_quant_files <- target_result$files[which,which_cols]
  gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))] <- 
    sapply(gene_quant_files[,which(unlist(lapply(gene_quant_files, is.list)))], paste )
  target_coldata <- cbind(query_table[i,], gene_quant_files)
  
  for(j in 1:nrow(target_coldata)){
    temp <- tempfile()
    download.file(paste0("https://www.encodeproject.org/",target_coldata$href[j]), temp)
    temp_data <- read.table(temp, skip = 0, header = TRUE, sep = "\t")
    temp_data <- temp_data[grep("PAR_Y",temp_data$gene_id, invert=T),]
    data_list[[length(data_list)+1]] <- list(TPM = data.frame(TPM=temp_data$TPM),
                                             coldata = cbind(target_coldata[j,], read_count=sum(temp_data$posterior_mean_count) ) )
    rownames(data_list[[length(data_list)]]$TPM) <- str_remove(temp_data$gene_id,"\\..*")
  }
}

temp_rownames <- character()
temp_data_list_qc <- data.frame(tpm_nrow=numeric(length=length(data_list)),
                                tpm_ncol=numeric(length=length(data_list)),
                                coldata_nrow=numeric(length=length(data_list)))
for(i in 1:length(data_list)){
  temp_data_list_qc$tpm_nrow[i] <- nrow(data_list[[i]]$TPM)
  temp_data_list_qc$tpm_ncol[i] <- ncol(data_list[[i]]$TPM)
  temp_data_list_qc$coldata_nrow[i] <- nrow(data_list[[i]]$coldata)
  temp_rownames <- unique(c(temp_rownames,rownames(data_list[[i]]$TPM)))
}
for(i in 1:length(data_list)){
  temp_missing_rownames <- setdiff(temp_rownames, rownames(data_list[[i]]$TPM))
  if(length(temp_missing_rownames)==0){next}
  temp_df <- data.frame(TPM = rep(0, length(temp_missing_rownames)))
  rownames(temp_df) <- temp_missing_rownames
  data_list[[i]]$TPM <- rbind(data_list[[i]]$TPM, temp_df)
}
for(i in 1:length(data_list)){
  temp_data_list_qc$tpm_nrow[i] <- nrow(data_list[[i]]$TPM)
  temp_data_list_qc$tpm_ncol[i] <- ncol(data_list[[i]]$TPM)
  temp_data_list_qc$coldata_nrow[i] <- nrow(data_list[[i]]$coldata)
}
#### fix dim mismatch issue for human data here ..... 
if( nrow(unique(temp_data_list_qc)) != 1){stop("dimension mismatch between objects")}

data_list_concat <- data_list[[1]]
for(i in 2:length(data_list)){
  data_list_concat$TPM <- cbind(data_list_concat$TPM, data_list[[i]]$TPM)
  data_list_concat$coldata <- rbind(data_list_concat$coldata, data_list[[i]]$coldata)
}
data_list_concat$coldata <- as.data.frame(data_list_concat$coldata)

dataset_list$ENCODE_HH <- list(mat = data_list_concat$TPM, coldata=data_list_concat$coldata)
rm(data_list)
```

```{r}
temp_onto <- ontos$uberon$ont
temp_onto$data_cols <- vector(mode = "list", length=length(temp_onto$id))
temp_ds <- dataset_list$ENCODE_MM_DEV$coldata
temp_ds <- dataset_list$ENCODE_HH$coldata

# add_annotation <- function(id, onto, annotation_name, annotation_value,
#                            propegate_to_ancestors=TRUE,
#                            propegate_from_part_to_whole=TRUE,
#                            allow_repeat_annotations=FALSE){
#   annotation_index <- which(names(onto)==annotation_name)
#   if(length(annotation_index)==0){stop(paste("annotation_name", annotation_name, "does not exist in ontology"))}
#   if(length(annotation_index)>1){stop(paste("annotation_name", annotation_name, "ambiguous in ontology"))}
#   which <- which(onto$id==id) 
#   if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
#   if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
#   
#   onto[[annotation_index]][[which]] <- c(onto[[annotation_index]][[which]], annotation_value)
#   if(!allow_repeat_annotations){
#     onto[[annotation_index]][[which]] <- unique(onto[[annotation_index]][[which]])
#   }
#   if(propegate_to_ancestors | length(onto$parents[[which]]) != 0){
#     for(parent in onto$parents[[which]]){
#       onto <- add_annotation(parent, onto, annotation_name, annotation_value,
#                              propegate_to_ancestors = propegate_to_ancestors,
#                              propegate_from_part_to_whole = propegate_from_part_to_whole,
#                              allow_repeat_annotations = allow_repeat_annotations)
#     }
#   }
#   return(onto)
# }

### cycle in is_a, part_of graph ? i.e. not a DAG?   
add_annotation <- function(id, onto, annotation_name,annotation_value,
                           transitive_relations=c("is_a","part_of"),
                           propegate_to_parents=TRUE,
                           visited_ids= c()){
  annotation_index <- which(names(onto)==annotation_name)
  if(length(annotation_index)==0){stop(paste("annotation_name", annotation_name, "does not exist in ontology"))}
  if(length(annotation_index)>1){stop(paste("annotation_name", annotation_name, "ambiguous in ontology"))}
  which <- which(onto$id==id)
  if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
  if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
  
  onto[[annotation_index]][[which]] <- unique(c(onto[[annotation_index]][[which]], annotation_value))
  ## set up and use blacklist of visited_ids
  #transitive_ids <- transitive_ids[which(transitive_ids != id)]
  visited_ids <- c(visited_ids,id)
  
  relation_df <- onto$relations[[which]]
  transitive_ids <- relation_df$id[which(is.element(relation_df$relation, transitive_relations))]
  if(propegate_to_parents){
    transitive_ids <- unique(c(transitive_ids,onto$parents[[which]]))
  }

  transitive_ids <- transitive_ids[!is.element(transitive_ids, visited_ids)]
  if(length(transitive_ids)>0){
    for( tid in transitive_ids ){
      #print(paste(onto$name[which], tid))
      onto <- add_annotation(id=tid, onto=onto, 
                             annotation_name = annotation_name,
                             annotation_value= annotation_value,
                             transitive_relations = transitive_relations,
                             propegate_to_parents = propegate_to_parents,
                             visited_ids=visited_ids )
    }
  }
  return(onto)
  
}

for(i in 1:nrow(temp_ds)){
  if(i %% 10 == 1){print(i)}
  onto_id <- str_replace(str_extract(temp_ds$biosample_ontology[i],"UBERON_[0-9]*"),"_",":")
  if(is.na(onto_id)){next}
  temp_onto <- add_annotation(onto_id, temp_onto,
                              annotation_name = "data_cols",
                              annotation_value = i,
                              transitive_relations=c("is_a","part_of"),
                              propegate_to_parents=TRUE )
  # col_id <- i
  
}

# add_inverse_relation <- function(onto, relation_to_invert, inverse_relation_name=NULL){
#   if(is.null(inverse_relation_name)){ inverse_relation_name <- paste0("INVERSE_",relation_to_invert) }
#   for(i in 1:length(onto)){
#     which(onto$relations[[i]]$relation == relation_to_invert)
#     
#   }
# }

### need to modify to enable extracting PART_OF relations here...... O_o
### get table of onto term and all descendants
get_desc_summary_table <- function(id,onto, level=1,
                                   transitive_relations=c("has_part"),
                                   descend_through_children=TRUE,
                                   visited_ids=c()){
  which <- which(onto$id==id) 
  if(length(which)==0){stop(paste("id", id, "does not exist in ontology"))}
  if(length(which)>1){stop(paste("id", id, "ambiguous in ontology"))}
  visited_ids <- c(visited_ids,id)
  
  temp_df <- as.data.frame(matrix(character() ,nrow = 1, ncol=length(onto),
                                  dimnames = list(NULL, names(onto))))
  for(el in names(onto)){
    if(is.data.frame(onto[[el]][[which]])){
      temp_df[el] <- paste0(apply(onto[[el]][[which]],1, paste0, collapse=","),collapse=";")
    } else if( is.list(onto[[el]][[which]] )){
      if(length(onto[[el]][[which]]) > 0){
       temp_df[el] <- sapply(onto[[el]][[which]], paste, collapse=",")
      } else { temp_df[el] <- NA }
    } else{
      temp_df[el] <- paste0(onto[[el]][[which]],collapse=",")
    } 
  }
  temp_df <- cbind(temp_df, data.frame(level=level))
  
  relation_df <- onto$relations[[which]]
  transitive_ids <- relation_df$id[which(is.element(relation_df$relation, transitive_relations))]
  if(descend_through_children){
    transitive_ids <- unique(c(transitive_ids,onto$children[[which]]))
  }
  transitive_ids <- transitive_ids[!is.element(transitive_ids, visited_ids)]
  
  if(length(transitive_ids) > 0 ){
    for(tid in transitive_ids){
      temp_df <- rbind(temp_df,
                       get_desc_summary_table(tid, onto, level=level+1,
                                              transitive_relations=transitive_relations,
                                              descend_through_children=descend_through_children,
                                              visited_ids=visited_ids))
    }
  }

  return(unique(temp_df))
}

muscle_df <- get_desc_summary_table("UBERON:0004120", temp_onto)
muscle_df$num_datasets <- sapply(str_split(muscle_df$data_cols,","), function(x){ifelse(all(x==""),0,length(x)) })
muscle_df_sub <- muscle_df[which(muscle_df$data_cols != ""),c("id","name","num_datasets","level")]
muscle_df_sub <- muscle_df_sub[order(muscle_df_sub$level),]

heart_df <- get_desc_summary_table("UBERON:0000948", temp_onto)
heart_df$num_datasets <- sapply(str_split(heart_df$data_cols,","), function(x){ifelse(all(x==""),0,length(x)) })
heart_df_sub <- heart_df[which(heart_df$data_cols != ""),c("id","name","num_datasets","level")]
heart_df_sub <- heart_df_sub[order(heart_df_sub$level),]

write.csv(muscle_df_sub, paste0(dirs$tables,"ENCODE_mesoderm_derived_RNAseq.csv"))
write.csv(heart_df_sub, paste0(dirs$tables,"ENCODE_heart_RNAseq.csv"))

```
