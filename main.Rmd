---
title: "main"
output: html_document
date: "2023-01-27"
author: "Leroy Bondhus"
---

```{r set up dir structure}
                         
dirs <- list(data="./data/",
             results = "./results/",
             tables = "./results/tables/",
             figures = "./results/figures/",
             temp_data ="/u/scratch/l/leroybon/chrom_mod_expr_landscape/",
             OMIM_data = "./data/omim_ra/")
for(dir in dirs){
  if(!dir.exists(dir)){dir.create(dir)}
};rm(dir)

files <- list()

####
date <- format(Sys.time(),"%Y%m%d")
```

```{r setup note}
#### NOTE : USER HAS TO REQUEST ACCESS TO A LINK FROM OMIM DIRECTLY TO GET THIS FILE #####
####        ONCE THIS IS DONE REPLACE "NULL" BELOW WITH THE URL TO genemap2.txt FILE #####

#OMIM_genemap2_URL <- "https://data.omim.org/downloads/##USER_ACCESS_PATTERN##/genemap2.txt"
OMIM_genemap2_URL <- NULL
#if(is.null(OMIM_genemap2_URL){rm(OMIM_genemap2_URL)}
####                                     END NOTE                                    #####

files$OMIM_GENE <- paste0(dirs$OMIM_data,"HPO_genes_to_phenotypes.txt")
if(!file.exists(files$OMIM_GENE)){
  if(!exists("OMIM_genemap2_URL")){
    stop(paste0( "Please visit https://www.omim.org/downloads and follow instructions to get URL link ",
                 "for 'genemap2.txt', then set OMIM_genemap2_URL variable to this link in this script " ))
  }
  download.file(OMIM_genemap2_URL, files$OMIM_GENE)
}
     
```

```{r load libraries}
req_packages <- list(
  standard = c("BiocManager","doParallel","ggplot2","stringr", "reshape2", "XML"),
  biocmanager = c("Gviz","biomaRt")
)
for(std_package in req_packages$standard ){
  if(!require(std_package, quietly=T, character.only=T)){install.packages(std_package)}
};rm(std_package)
for(bioc_package in req_packages$biocmanager ){
  if(!require(bioc_package, quietly=T, character.only=T)){BiocManager::install(bioc_package)}
};rm(bioc_package)
rm(req_packages)
```


```{r, ontos helper functions}
## assume ontology is list of elements of equal length
## elements must include "id", "name", "parents", "children"

add_children_from_parents <- function(onto){
  for(i in 1:length(onto$id)){
    if(length(onto$parents[[i]])<1){next}
    which <- which(is.element(onto$id, onto$parents[[i]]))
    for(j in which){
      onto$children[[j]] <- c(onto$children[[j]], onto$id[i])
    }
  }
  return(onto)
}

get_descendants <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$children[[which]]) == 0){
    return(onto$id[which])
  }
  descendants <- id
  for(child in onto$children[[which]]){
    descendants <- unique(c(descendants, get_descendants(child, onto)))
  }
  return(descendants)
}

get_height <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$children[[which]]) == 0){
    return(1)
  }
  max_child_height <- 0
  for(child in onto$children[[which]]){
    max_child_height <- max(max_child_height, get_height(child, onto))
  }
  return(max_child_height+1)
}

get_depth <- function(id, onto){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(length(onto$parents[[which]]) == 0){
    return(1)
  }
  max_parent_depth <- 0
  for(parent in onto$parents[[which]]){
    max_parent_depth <- max(max_parent_depth, get_depth(parent, onto))
  }
  return(max_parent_depth+1)
}

get_mask_set <- function(id, onto){ #}, mask_self=T){
  which <- which(onto$id==id)
  if(length(which)==0){ stop(paste0("id: ",id,", not in ontology")) }
  if(length(which)>1){ stop(paste0("id: ",id,", not unique in ontology")) }
  if(onto$is_signif[which] ){
    return(onto$id[which]) ## if signif, end recursion down since don't need to also mask descendants
  } else {
    mask_set <- character(length=0)
  }
  if(length(onto$children[[which]]) > 0){ 
    for(child in onto$children[[which]]){
      mask_set <- c(mask_set, get_mask_set(child,onto)) # ,mask_self=F)) 
    }
  }
  return(unique(mask_set))
}
```

```{r, organize ontologies}


ontos <- list()
ontos$go = list(
  URL = "http://purl.obolibrary.org/obo/go.obo"
)

files$go_obo <- paste0(dirs$temp_data,"go.obo")
download.file(ontos$go$URL,files$go_obo)

##### read in and set up ontology ####
con <- file(files$go_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^\\[Term\\]$",line)
}
close(con)

ontos$go$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
con <- file(files$go_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    term_num <- term_num + 1
  } else if(grepl("^id:.*GO:",line)){
    ontos$go$ont$id[term_num] <- str_extract(line, "GO:[0-9]+")
  } else if(grepl("^name:",line)){
    ontos$go$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^namespace:",line)){
    ontos$go$ont$namespace[term_num] <- str_remove(line, "^namespace:[[:space:]]")
  } else if(grepl("^is_a:",line)){
    ontos$go$ont$parents[term_num][[1]] <- c(ontos$go$ont$parents[term_num][[1]], str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line)){
    ontos$go$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con)

### replace is_a with parents
### add children attribute to each term for ease of navigation up and down ontology
ontos$go$ont <- add_children_from_parents(ontos$go$ont)

##### done: read in and set up ontology ####





## uberon
## hpo
ontos$hpo <- list()
ontos$hpo$URL <- "https://github.com/obophenotype/human-phenotype-ontology/raw/master/hp.obo"

files$hp_obo <- paste0(dirs$temp_data,"hp.obo")
download.file(ontos$hpo$URL,files$hp_obo)


con <- file(files$hp_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^\\[Term\\]$",line)
}
close(con)

ontos$hpo$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
#  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
con <- file(files$hp_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    term_num <- term_num + 1
  } else if(grepl("^id:.*HP:",line)){
    ontos$hpo$ont$id[term_num] <- str_extract(line, "HP:[0-9]+")
  } else if(grepl("^name:",line)){
    ontos$hpo$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^is_a:",line)){
    ontos$hpo$ont$parents[term_num][[1]] <- c(ontos$hpo$ont$parents[term_num][[1]], str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line)){
    ontos$hpo$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con)
ontos$hpo$ont <- add_children_from_parents(ontos$hpo$ont)


## set up uberon ontology ###
ontos$uberon <- list()
ontos$uberon$URL <- "https://github.com/obophenotype/uberon/releases/download/v2023-02-14/uberon-full.obo"

files$uberon_obo <- paste0(dirs$temp_data,"uberon-full.obo")
download.file(ontos$uberon$URL,files$uberon_obo)


con <- file(files$uberon_obo,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("^id:.*UBERON:",line)
}
close(con)

ontos$uberon$ont <- list(
  id=character(length = num_terms ),
  name=character(length = num_terms ),
#  namespace = character(length = num_terms ),
  parents = vector("list", num_terms),
  children = vector("list", num_terms),
  relation = vector("list", num_terms),
  is_obsolete = rep(FALSE, num_terms)
)

term_num <- 0
is_uberon <- FALSE
con <- file(files$uberon_obo,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("^\\[Term\\]$",line)){
    is_uberon <- FALSE
  } else if(grepl("^id:.*UBERON:",line)){
    term_num <- term_num + 1
    ontos$uberon$ont$id[term_num] <- str_extract(line, "UBERON:[0-9]+")
    is_uberon <- TRUE
  } else if(grepl("^name:",line) & is_uberon){
    ontos$uberon$ont$name[term_num] <- str_remove(line, "^name:[[:space:]]")
  } else if(grepl("^is_a:.*UBERON",line) & is_uberon){
    ontos$uberon$ont$parents[term_num][[1]] <- c(ontos$uberon$ont$parents[term_num][[1]],
                                                 str_remove(str_remove(line, "^is_a:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^relationship:.*UBERON",line) & is_uberon){
    ontos$uberon$ont$relation[term_num][[1]] <- c(ontos$uberon$ont$parents[term_num][[1]],
                                                 str_remove(str_remove(line, "^relationship:[[:space:]]"),"[[:space:]]*!.*")) 
  } else if(grepl("^is_obsolete: true",line) & is_uberon){
    ontos$uberon$ont$is_obsolete[term_num] <- TRUE 
  }
}
close(con)
ontos$uberon$ont <- add_children_from_parents(ontos$uberon$ont)


```



```{r, organize dbs}
dbs <- list()
dbs$OMIM_GENE <- list()

##### read in and set up MIM gene to disease database (aka map) ####
con <- file(files$OMIM_GENE,open="r")
temp_header <- readLines(con, 4)[4]
temp_header <- str_remove(temp_header,"# ")
temp_header <- str_split_1(temp_header,"\t")
close(con)
dbs$OMIM_GENE$map <- read.delim2(files$OMIM_GENE, header=FALSE, comment.char="#")
colnames(dbs$OMIM_GENE$map) <- str_replace_all(temp_header,"[[:space:]]","_")
dbs$OMIM_GENE$map <- dbs$OMIM_GENE$map[complete.cases(dbs$OMIM_GENE$map),]
### FURTHER PARSING NECESSARY: COLUMN "Phenotypes" contains actual phenotype OMIM ID, MIM_Number is for gene's mim number...
###                            for "Phenotypes" column, only use those associated with (3) which indicates gene found causative
dbs$OMIM_GENE$map <- dbs$OMIM_GENE$map[,c("Ensembl_Gene_ID","Phenotypes")]

temp <- str_split(dbs$OMIM_GENE$map$Phenotypes,";")
names(temp) <- dbs$OMIM_GENE$map$Ensembl_Gene_ID
temp <- melt(temp); colnames(temp) <- c("Phenotype","Ensembl_Gene_ID")
temp$temp_str <- str_extract(temp$Phenotype,"[0-9]{6}.*\\([0-4]\\).*")
temp$evidence_code <- str_extract(temp$temp_str,"\\([0-4]\\)")
temp$inheritance_mode <- str_extract(temp$temp_str,"[a-zA-Z].*")
temp$OMIM_ID <- str_extract(temp$temp_str,"[0-9]{6}")
temp$temp_str <- NULL
temp$Phenotype <-  str_remove(temp$Phenotype,", [0-9]{6}.*")

dbs$OMIM_GENE$map <- temp

dbs$HPO_OMIM <- list()
##### try other file......
dbs$HPO_OMIM$URL <- "http://purl.obolibrary.org/obo/hp/hpoa/phenotype.hpoa"
files$HPO_OMIM <- paste0(dirs$temp_data,"phenotype.hpoa")
download.file(dbs$HPO_OMIM$URL, files$HPO_OMIM)
### column descriptors https://hpo-annotation-qc.readthedocs.io/en/latest/annotationFormat.html#phenotype-hpoa-format
##### read in and set up HPO gene to phenotype map ####
dbs$HPO_OMIM$map <- read.csv(files$HPO_OMIM,sep="\t",skip=4)
dbs$HPO_OMIM$map <- dbs$HPO_OMIM$map[grepl("OMIM",dbs$HPO_OMIM$map$X.DatabaseID),]
colnames(dbs$HPO_OMIM$map)[which(colnames(dbs$HPO_OMIM$map)=="X.DatabaseID")] <- "OMIM_ID"


dbs$HPO_OMIM_GENE <- list()
temp1 <- dbs$HPO_OMIM$map[,c("OMIM_ID","HPO_ID")]
temp2 <- dbs$OMIM_GENE$map[c("Ensembl_Gene_ID","OMIM_ID")]
temp2$OMIM_ID <- paste0("OMIM:",temp2$OMIM_ID)
dbs$HPO_OMIM_GENE$map <- merge(temp1,temp2)



### HPO to UBERON
## hpo
dbs$HPO_UBERON <- list()
dbs$HPO_UBERON$URL <- "https://github.com/obophenotype/human-phenotype-ontology/raw/master/hp.owl"

files$hp_owl <- paste0(dirs$temp_data,"hp.owl")
download.file(dbs$HPO_UBERON$URL,files$hp_owl)


con <- file(files$hp_owl,open="r")
num_terms <- 0
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){break}
  num_terms <- num_terms + grepl("<!--.*HP_",line)
}
close(con)

dbs$HPO_UBERON$map <- list(
  HPO_id=character(length = num_terms ),
  UBERON_terms = vector("list", num_terms)
)

term_num <- 0
on_HPO_term <- FALSE
con <- file(files$hp_owl,open="r")
while(TRUE){
  line = readLines(con,n=1)
  if(length(line)==0){
    break
  } else if(grepl("<!--.*HP_",line)){
    term_num <- term_num + 1
    dbs$HPO_UBERON$map$HPO_id[term_num] <- str_extract(line, "HP_[0-9]+")
    on_HPO_term <- TRUE
  } else if(grepl("UBERON",line) & on_HPO_term){
    dbs$HPO_UBERON$map$UBERON_terms[[term_num]] <- c(dbs$HPO_UBERON$map$UBERON_terms[[term_num]], 
                                                        str_extract(line, "UBERON_[0-9]+"))
  } else if(grepl("<!--",line)){
    on_HPO_term <- FALSE
  }
}
close(con)

dbs$HPO_UBERON$map$UBERON_terms[sapply(dbs$HPO_UBERON$map$UBERON_terms, is.null)] <- NA 
names(dbs$HPO_UBERON$map$UBERON_terms) <- dbs$HPO_UBERON$map$HPO_id
temp <- reshape2::melt(dbs$HPO_UBERON$map$UBERON_terms)
colnames(temp) <- c("UBERON_ID","HPO_ID")
temp$UBERON_ID <- str_replace_all(temp$UBERON_ID, "_",":")
temp$HPO_ID <- str_replace_all(temp$HPO_ID,"_",":")
dbs$HPO_UBERON$map <- temp[,c("HPO_ID","UBERON_ID")]





```


```{r, organize gene sets}
ensembl <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
options(timeout=300)
gene_sets <- list()
### these pulls are fairly time intensive -> consider saving to data in short term and load if exists
gene_sets$genes_all <- getBM(attributes=c('ensembl_gene_id',"external_gene_name",
                                          "start_position","end_position"),
                 mart = ensembl, useCache = F)

## alternatively download from: http://geneontology.org/gene-associations/goa_human.gaf.gz
for(chr in c(as.character(1:22),"X","Y","MT" )){
  temp <- getBM(attributes=c('ensembl_gene_id',"external_gene_name",
                             "ensembl_transcript_id","transcript_length",
                             "chromosome_name", "exon_chrom_start","exon_chrom_end","rank"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  temp2 <- getBM(attributes=c('ensembl_gene_id',
                             "ensembl_transcript_id",
                             "transcript_is_canonical"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  temp <- merge(temp, temp2)
  gene_sets$genes_all_transcript <- rbind(gene_sets$genes_all_transcript, temp)
  
  temp <- getBM(attributes=c('ensembl_gene_id',"external_gene_name","go_id","name_1006"),
                filters = "chromosome_name",
                values = chr,
                mart = ensembl, useCache = F)
  gene_sets$genes_all_go <- rbind(gene_sets$genes_all_go, temp)
  
}
gene_sets$genes_all_transcript <- gene_sets$genes_all_transcript[which(!is.na(gene_sets$genes_all_transcript$transcript_is_canonical)),]

gene_sets$human_chromatin_modifiers <- list()
gene_sets$human_chromatin_modifiers$go_terms = c( "histone acetyltransferase activity",
                                        "histone deacetylase activity",
                                        "histone methyltransferase activity",
                                        "histone demethylase activity",
                                        "histone ubiquitin ligase activity",
                                        "histone deubiquitinase activity",
                                        "histone kinase activity",
                                        "histone phosphatase activity",
                                      ##  "chromatin remodeling", too broad
                                      ##  "chromatin organization", too broad
                                        "nucleosome organization",
                                        "chromatin looping",
                                        "heterochromatin organization",
                                        "DNA-methyltransferase activity",
                                        "DNA demethylase activity")


## for each term in chrom_go_terms, check which genes are associated with term (and any of it's descendants)
#### for each term, get all descendant terms
go_funcs <- list()
go_funcs$get_descendants <- function(id,go){
  which <- which(go$id == id)
  descendants <- go$id[which] ### a term is considered a descendant of itself
  if( length(go$children[[which]])==0 ){return(descendants)}
  for(child in go$children[[which]]){
    descendants <- unique(c(descendants, go_funcs$get_descendants(child, go) ))
  }
  return(descendants)
}

gene_sets$human_chromatin_modifiers$go_ids <- character(length = length(gene_sets$human_chromatin_modifiers$go_terms))
gene_sets$human_chromatin_modifiers$gene_subsets <- vector("list",length(gene_sets$human_chromatin_modifiers$go_terms))
names(gene_sets$human_chromatin_modifiers$gene_subsets ) <- gene_sets$human_chromatin_modifiers$go_terms
for(i in 1:length(gene_sets$human_chromatin_modifiers$go_terms)){
  ## which go onto node has the current term
  which <- which(ontos$go$ont$name == gene_sets$human_chromatin_modifiers$go_terms[i])
  term_id <- ontos$go$ont$id[which]
  gene_sets$human_chromatin_modifiers$go_ids[i] <- term_id
  
  ## genes which have GO id for current term or any of it's descendants
  descendants <- go_funcs$get_descendants(term_id, ontos$go$ont)
  gene_sets$human_chromatin_modifiers$gene_subsets[[i]] <-
    unique(gene_sets$genes_all_go$ensembl_gene_id[which(is.element(gene_sets$genes_all_go$go_id, descendants ))])
  
}

gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers <- unique(unlist(gene_sets$human_chromatin_modifiers$gene_subsets))


## human
## mouse
## zebrafish
## celegans
## fly 
## chromatin modifier


```

```{r, custom ggplot themes}
barcode_theme <- theme_classic()+
  theme(axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y  = element_blank(),
        axis.ticks.y = element_blank()
  )


```

```{r, look at basic chromatin modifier summary statistics}

## gene length
## transcript length
## exon count
## exon size
ggl <- list()
for(i in 14){ #  1:length(gene_sets$human_chromatin_modifiers$gene_subsets)){
  chrom_subset <- gene_sets$human_chromatin_modifiers$gene_subsets[[i]] 
  chrom_subset_name <- names(gene_sets$human_chromatin_modifiers$gene_subsets)[i]
  if(length(chrom_subset)==0){next}
  ## gene length density + barcode plots
  df <- gene_sets$genes_all[which(is.element(gene_sets$genes_all$ensembl_gene_id, chrom_subset )),]
  df$gene_length <- df$end_position - df$start_position
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length density")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(gene_length)))+
    ggtitle(temp_name)+
    geom_density(alpha=0.5)
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length barcode")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(gene_length),xend=log10(gene_length), y=0,yend=1))+
    ggtitle(temp_name)+
    geom_segment(alpha=0.5)+
    coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
    barcode_theme
  
  ## transcript length density + barcode plot
  df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, chrom_subset )),]
  df <- unique(df[,c("ensembl_gene_id", "transcript_length")])
  
  temp_name <- paste0(chrom_subset_name, ": ", "transcript_length density")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(transcript_length)))+
    ggtitle(temp_name)+
    geom_density(alpha=0.5)
  
  temp_name <- paste0(chrom_subset_name, ": ", "transcript_length barcode")
  ggl[[temp_name]] <-  ggplot(df, aes(x=log10(transcript_length),xend=log10(transcript_length), y=0,yend=1))+
    ggtitle(temp_name)+
    geom_segment(alpha=0.5)+
    coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
    barcode_theme
   
  
  
  ## exon length  plot
  df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, chrom_subset )),]
  #df <- gene_sets$genes_all_transcript[which(is.element(gene_sets$genes_all_transcript$ensembl_gene_id, sample(unique(gene_sets$genes_all$ensembl_gene_id),45) )),]
  df$exon_length <- df$exon_chrom_end - df$exon_chrom_start
  df$gene_factor_num <- as.numeric(as.factor(df$ensembl_gene_id))
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length")
  ggl[[temp_name]] <- ggplot(df, aes(x=log10(exon_length),y=gene_factor_num))+
    ggtitle(temp_name)+
    geom_point(fill="grey20") +
    coord_cartesian( xlim = c(1, 4))+
    barcode_theme
  
  
  ## exon count plot
  temp_df <- as.data.frame(table(df$ensembl_transcript_id))
  colnames(temp_df)[1] <- "ensembl_transcript_id"
  colnames(temp_df)[2] <- "exon_count"
  df <- merge(df, temp_df, sort=FALSE)
  
  ## test 2d plot of exon count by min size
  
  temp <- split(df$exon_length, df$ensembl_transcript_id)
  temp <- sapply(temp, function(x) rank(-x, ties.method = "last"))
  df$exon_length_rank <- unsplit(temp, df$ensembl_transcript_id)
  
  temp <- split(df$exon_length, df$exon_length_rank) 
  temp <- sapply(temp, sort, decreasing=T)
  temp <- melt(temp)
  temp2 <- split(temp$value, temp$L1)
  num_genes <- length(unique(df$ensembl_gene_id))
  temp2 <- sapply(temp2, function(x) (1:length(x))/num_genes )
  temp2 <- unsplit(temp2, temp$L1)
  temp$percentile <- temp2
  temp$L1 <- as.numeric(temp$L1)
  temp <- temp[order(temp$L1, temp$percentile),]
  temp$L1 <- as.factor(temp$L1)
  colnames(temp) <- c("exon_length","exon_rank_by_length","percentile")
  temp_name <- paste0(chrom_subset_name, ": ", "genes_w_N_exons_of_size_or_greater")
  ggl[[temp_name]] <- ggplot(temp, aes(log10(exon_length), percentile, group=exon_rank_by_length, color=exon_rank_by_length))+
    ggtitle(temp_name)+
    geom_line()
  
  temp <- split(df$rank, df$ensembl_transcript_id)
  temp <-sapply(temp, function(x) order(-x))
  temp <- unsplit(temp, df$ensembl_transcript_id)
  df$rank_from_end <- temp
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length v rank")
  ggl[[temp_name]] <- ggplot(df, aes(rank, log10(exon_length) ))+
    ggtitle(temp_name)+
    geom_point(alpha=0.5)
  temp_name <- paste0(chrom_subset_name, ": ", "exon_length v rank_from_end")
  ggl[[temp_name]] <- ggplot(df, aes(rank_from_end, log10(exon_length) ))+
    ggtitle(temp_name)+
    geom_point(alpha=0.5)
  
}

dirs$gene_arch_summary_figs <- paste0(dirs$figures,"gene_arch_summary_figures/")
if(!dir.exists(dirs$gene_arch_summary_figs)){dir.create(dirs$gene_arch_summary_figs)}
for(i in 1:length(ggl)){
  
  temp_filename <- paste0(dirs$gene_arch_summary_figs,names(ggl)[i],".png")
  temp_filename <- str_replace_all(temp_filename,"[ \t:]","_")
  w <- 7
  h <- ifelse(grepl("barcode", temp_filename), 3, 5)
  ggsave(temp_filename, ggl[[i]], device = "png", width=w, height=h)
}

```

```{r, look at basic disease association statistics }

### look at pLI

temp <- tempfile()
download.file("https://storage.googleapis.com/gcp-public-data--gnomad/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz",temp)
lof_metrics <- read.table( temp, skip=0, header = TRUE, sep = "\t")

temp <- tempfile()
download.file("http://geneontology.org/gene-associations/goa_human_complex.gaf.gz",temp)
go_complex_metrics <- read.table( temp, skip=0, header = TRUE, sep = "\t")

ggl2 <- list()
for(i in 14){ #  1:length(gene_sets$human_chromatin_modifiers$gene_subsets)){
  chrom_subset <- gene_sets$human_chromatin_modifiers$gene_subsets[[i]] 
  chrom_subset_name <- names(gene_sets$human_chromatin_modifiers$gene_subsets)[i]
  if(length(chrom_subset)==0){next}
  
  df <- lof_metrics[which(is.element(lof_metrics$gene_id, chrom_subset)),] 
  id_cols <- c("gene","gene_id","gene_type")
  var_cols <- c("oe_mis","oe_syn","oe_lof","no_lofs","obs_het_lof","obs_hom_lof", "pLI","oe_lof_upper","syn_z","mis_z","lof_z")
  df_melt <- melt(df, id.vars=id_cols, measure.vars = var_cols)
  
  temp_name <- paste0(chrom_subset_name, ": ", "gene_length density")
  ggplot(df_melt[grep("oe", df_melt$variable),],aes(x=variable, y=value))+
    geom_violin() 
  ggplot(df_melt[grep("_z", df_melt$variable),],aes(x=variable, y=value))+
    geom_violin()
  ggplot(df_melt[grep("pLI", df_melt$variable),],aes(y=value))+
    geom_histogram()
  ggplot(df_melt[grep("oe_lof_upper", df_melt$variable),],aes(y=value))+
    geom_histogram()
  
  
  ### GET all associated with Mendelian disorder (e.g. v pLI)

}


## for each HPO, test enrichment of chrom modifiers in set
## plot by signif and OR, add labels (padj by bonferroni)



which <- which(is.element(dbs$HPO_OMIM_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- dbs$HPO_OMIM_GENE$map[which,]
temp_not_chrom <- dbs$HPO_OMIM_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
temp_res_df <- data.frame(p.value=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio_lb=numeric(length(ontos$hpo$ont$id)),
                          odds_ratio_ub=numeric(length(ontos$hpo$ont$id)))

for(i in 1:length(ontos$hpo$ont$id)){
  if(i %% 1000 == 1){print(i)}
  hps <- get_descendants(ontos$hpo$ont$id[i], ontos$hpo$ont)
  
  which <- which(is.element(temp_chrom$HPO_ID, hps))
  temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <- which(is.element(temp_not_chrom$HPO_ID, hps))
  temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))

    ### Use all genes or only those with some HP association ?
  which <-  which(!is.element(temp_chrom$HPO_ID, hps))
  temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
  which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
  temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
  ## chrom and hp
  
  ## chrom and not hp
  ## not chrom and hp
  ## not chrom and not hp
  
  temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                  c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
  
  ## Odds Ratio
  temp_res_df$p.value[i] <- temp_res$p.value
  temp_res_df$odds_ratio[i] <- temp_res$estimate
  temp_res_df$odds_ratio_lb[i] <- temp_res$conf.int[1]
  temp_res_df$odds_ratio_ub[i] <- temp_res$conf.int[2]
}


## plot Gene-Gene phenotype similarity (asymetric if want subsumption test e.g.  if A has subset of phens of B)
## subsumption test may be useful later if make meta-genes by aggregation of complex components..... 

```

```{r, experimental ontology layered analysis}

which <- which(is.element(dbs$HPO_OMIM_GENE$map$Ensembl_Gene_ID,
           gene_sets$human_chromatin_modifiers$gene_subsets$all_chrom_modifiers))
temp_chrom <- dbs$HPO_OMIM_GENE$map[which,]
temp_not_chrom <- dbs$HPO_OMIM_GENE$map[-which,]
temp_not_chrom <- temp_not_chrom[which(temp_not_chrom$Ensembl_Gene_ID!=""),]
onto <- ontos$hpo$ont

onto$height <- numeric(length=length(onto$id))
onto$depth <- numeric(length=length(onto$id))
for(i in 1:length(onto$id)){
  if(i %% 500 == 0){print(i)}
  onto$height[i] <- get_height(onto$id[i],onto)
  onto$depth[i] <- get_depth(onto$id[i],onto)
}


onto$is_signif <- rep(F,length(onto$id))
for( layer in 1:max(onto$height)){
  print(paste0("layer is: ",layer ))
  els_in_layer <- which(onto$height==layer)
  i = 1
  for( el in els_in_layer ){
    if(i %% 250 == 0){print(i)}
    i <- i+1
    hps <- get_descendants(onto$id[el], onto)
  
    which <- which(is.element(temp_chrom$HPO_ID, hps))
    temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <- which(is.element(temp_not_chrom$HPO_ID, hps))
    temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
  
      ### Use all genes or only those with some HP association ?
    which <-  which(!is.element(temp_chrom$HPO_ID, hps))
    temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
    which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
    temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
    
    temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                  c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
    
    is_signif <- temp_res$p.value < 0.05
    if(!is_signif){next}
    ## get list of signif children - these form the mask set.. 
    ## actually.. probs want all signif descendants? Probs don't
    ## need to deal with children of signif children, but children of
    ## insignif children may themselves have substantial signal/ be signif...
    ## and then drive association at later ancestor level.. 
    
    #children_subset <- which(is.element(onto$id, onto$children[[el]]))
    
    # children_subset <- which(is.element(onto$id, get_descendants(onto$id[el],onto)))
    # 
    # which_children_signif <- children_subset[which(onto$is_signif[children_subset])]
    # signif_children <- onto$id[which_children_signif] 
    # signif_children <- signif_children[which(!is.element(signif_children,onto$id[el]))] # remove _self_ from descendants
    
    signif_children <- get_mask_set(onto$id[el], onto)
    
    if(length(signif_children>0)){ ### replace with children that are already called as significant only
      for( child in signif_children){
        hps <- onto$id[el] ## want to retain any that are directly associated with _self_.. 
        ## NOTE: Don't want to retain _self_ in hps if database includes redundant associations.. i.e. database should
        ## only include most specific instance and NOT also all ancestors of that instance ..
        for( other_child in signif_children){
          if( other_child == child){next}
          hps <- c(hps, get_descendants(other_child, onto))
        } 
  
        which <- which(is.element(temp_chrom$HPO_ID, hps))
        temp_chrom_hp <- length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <- which(is.element(temp_not_chrom$HPO_ID, hps))
        temp_not_chrom_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
      
          ### Use all genes or only those with some HP association ?
        which <-  which(!is.element(temp_chrom$HPO_ID, hps))
        temp_chrom_not_hp <-  length(unique(temp_chrom$Ensembl_Gene_ID[which]))
        which <-  which(!is.element(temp_not_chrom$HPO_ID, hps))
        temp_not_chrom_not_hp <- length(unique(temp_not_chrom$Ensembl_Gene_ID[which]))
        
        temp_res <- fisher.test(x=cbind(c(temp_chrom_hp, temp_chrom_not_hp),
                                      c(temp_not_chrom_hp, temp_not_chrom_not_hp)))
        is_signif <- temp_res$p.value < 0.05 
        if(!is_signif){break}
      }
      
    }
    onto$is_signif[el] <- is_signif
  }
}
save.image()
```

```{r, }
##phenotype complexity/diversity of genes -> system of affect complexity/diversity
```


```{r DRAFT extract protein complex associations}


### xml structure --- dissect xml in R to recapitulate each complex and it's member species
files$human_complexes <- paste0(dirs$temp_data,"human_complexes.zip")
#download.file("http://ftp.ebi.ac.uk/pub/databases/intact/complex/current/psi30/human.zip", files$human_complexes )
dirs$human_complexes <- str_remove(files$human_complexes,".zip")
#system(paste0("unzip ",files$human_complexes, " -d ", dirs$temp_data))
#system(paste0("mv ", dirs$temp_data, "human ", dirs$human_complexes))

temp_files <- list.files(dirs$human_complexes, full.names = T)
complex <- list()
i = 1
for(f in temp_files){
  if( i %% 20 ==1 ){print(paste0(basename(f),": ",i, " of ", length(temp_files)))}
  complex_metrics <- xmlParse(f)
  complex_metrics <- xmlToList(complex_metrics)
  i <- i+1
  
  complex_name <- complex_metrics$entry$interactionList$abstractInteraction$names$shortLabel
  complex_id <- paste0(complex_metrics$entry$interactionList$abstractInteraction$xref$primaryRef,collapse="__")
  complex[[complex_name]] <- list(name = complex_name,
                                  id = complex_id,
                                  members = c())
  for(interactor in complex_metrics$entry$interactorList){
    temp <- sapply(interactor$xref, function(x){paste0(x,collapse="__")} )
    temp <- temp[grep("ENSG.*gene",temp)]
    if(length(temp)==0){next}
    complex[[complex_name]]$members <- c(complex[[complex_name]]$members,
                                         str_extract(temp,"ENSG[0-9]*"))
  }  
}

### FOR EACH CHROM MODIFIER -> ID NUM OF COMPLEX SPECIES AND THEIR RESPECTIVE NUMBER OF TOTAL UNIQUE SUBUNITS ID'D
### PLOT SUMMARY DISTRIBUTION FOR ALL GENES
### BARCODE PLOT


# ggplot(df, aes(log2(transcript_length, )))+
#   geom_histogram(bins=500, alpha=0.7, fill="grey20")+
#   coord_cartesian(ylim = c(0.2,0.5), xlim = c(2, 6.5))+
#   barcode_theme
    #theme_bw()+


```



```{r, organize datasets}

dataset_list <- list()
## encode (has uberon, standard format)
## gtex (has uberon, standard format)
## sra (mixed format)


```

